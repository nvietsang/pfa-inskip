   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"simpleserial-glitch.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.aes_gen_tables,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  23              	aes_gen_tables:
  24              	.LFB13:
  25              		.file 1 "simpleserial-glitch.c"
   1:simpleserial-glitch.c **** /*
   2:simpleserial-glitch.c ****     This file is part of the ChipWhisperer Example Targets
   3:simpleserial-glitch.c ****     Copyright (C) 2012-2020 NewAE Technology Inc.
   4:simpleserial-glitch.c **** 
   5:simpleserial-glitch.c ****     This program is free software: you can redistribute it and/or modify
   6:simpleserial-glitch.c ****     it under the terms of the GNU General Public License as published by
   7:simpleserial-glitch.c ****     the Free Software Foundation, either version 3 of the License, or
   8:simpleserial-glitch.c ****     (at your option) any later version.
   9:simpleserial-glitch.c **** 
  10:simpleserial-glitch.c ****     This program is distributed in the hope that it will be useful,
  11:simpleserial-glitch.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:simpleserial-glitch.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:simpleserial-glitch.c ****     GNU General Public License for more details.
  14:simpleserial-glitch.c **** 
  15:simpleserial-glitch.c ****     You should have received a copy of the GNU General Public License
  16:simpleserial-glitch.c ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:simpleserial-glitch.c **** */
  18:simpleserial-glitch.c **** 
  19:simpleserial-glitch.c **** #include "hal.h"
  20:simpleserial-glitch.c **** 
  21:simpleserial-glitch.c **** 
  22:simpleserial-glitch.c **** #include "simpleserial.h"
  23:simpleserial-glitch.c **** 
  24:simpleserial-glitch.c **** 
  25:simpleserial-glitch.c **** #include "common.h"
  26:simpleserial-glitch.c **** #include "aes.h"
  27:simpleserial-glitch.c **** #include <string.h>
  28:simpleserial-glitch.c **** #include <stdio.h>
  29:simpleserial-glitch.c **** #include <time.h>
  30:simpleserial-glitch.c **** #include <stdint.h>
  31:simpleserial-glitch.c **** #include <stdlib.h>
  32:simpleserial-glitch.c **** 
  33:simpleserial-glitch.c **** /*
  34:simpleserial-glitch.c ****  * Forward S-box & tables
  35:simpleserial-glitch.c ****  */
  36:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static unsigned char FSb[256];
  37:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t FT0[256];
  38:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t FT1[256];
  39:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t FT2[256];
  40:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t FT3[256];
  41:simpleserial-glitch.c **** 
  42:simpleserial-glitch.c **** /*
  43:simpleserial-glitch.c ****  * Reverse S-box & tables
  44:simpleserial-glitch.c ****  */
  45:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static unsigned char RSb[256];
  46:simpleserial-glitch.c **** 
  47:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t RT0[256];
  48:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t RT1[256];
  49:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t RT2[256];
  50:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t RT3[256];
  51:simpleserial-glitch.c **** 
  52:simpleserial-glitch.c **** /*
  53:simpleserial-glitch.c ****  * Round constants
  54:simpleserial-glitch.c ****  */
  55:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static uint32_t round_constants[10];
  56:simpleserial-glitch.c **** 
  57:simpleserial-glitch.c **** /*
  58:simpleserial-glitch.c ****  * Tables generation code
  59:simpleserial-glitch.c ****  */
  60:simpleserial-glitch.c **** #define ROTL8(x) (((x) << 8) & 0xFFFFFFFF) | ((x) >> 24)
  61:simpleserial-glitch.c **** #define XTIME(x) (((x) << 1) ^ (((x) & 0x80) ? 0x1B : 0x00))
  62:simpleserial-glitch.c **** #define MUL(x, y) (((x) && (y)) ? pow[(log[(x)]+log[(y)]) % 255] : 0)
  63:simpleserial-glitch.c **** 
  64:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static int aes_init_done = 0;
  65:simpleserial-glitch.c **** 
  66:simpleserial-glitch.c **** MBEDTLS_MAYBE_UNUSED static void aes_gen_tables(void)
  67:simpleserial-glitch.c **** {
  26              		.loc 1 67 1 view -0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 512
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  68:simpleserial-glitch.c ****     int i;
  30              		.loc 1 68 5 view .LVU1
  69:simpleserial-glitch.c ****     uint8_t x, y, z;
  31              		.loc 1 69 5 view .LVU2
  70:simpleserial-glitch.c ****     uint8_t pow[256];
  32              		.loc 1 70 5 view .LVU3
  71:simpleserial-glitch.c ****     uint8_t log[256];
  33              		.loc 1 71 5 view .LVU4
  72:simpleserial-glitch.c **** 
  73:simpleserial-glitch.c ****     /*
  74:simpleserial-glitch.c ****      * compute pow and log tables over GF(2^8)
  75:simpleserial-glitch.c ****      */
  76:simpleserial-glitch.c ****     for (i = 0, x = 1; i < 256; i++) {
  34              		.loc 1 76 5 view .LVU5
  35              	.LVL0:
  36              		.loc 1 76 24 view .LVU6
  67:simpleserial-glitch.c ****     int i;
  37              		.loc 1 67 1 is_stmt 0 view .LVU7
  38 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  39              	.LCFI0:
  40              		.cfi_def_cfa_offset 20
  41              		.cfi_offset 4, -20
  42              		.cfi_offset 5, -16
  43              		.cfi_offset 6, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 ADF5017D 		sub	sp, sp, #516
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 536
  49 0006 6846     		mov	r0, sp
  50              		.loc 1 76 19 view .LVU8
  51 0008 0123     		movs	r3, #1
  52              		.loc 1 76 12 view .LVU9
  53 000a 0022     		movs	r2, #0
  54 000c 0546     		mov	r5, r0
  77:simpleserial-glitch.c ****         pow[i] = x;
  78:simpleserial-glitch.c ****         log[x] = (uint8_t) i;
  55              		.loc 1 78 16 view .LVU10
  56 000e 40AC     		add	r4, sp, #256
  57              	.LVL1:
  58              	.L3:
  77:simpleserial-glitch.c ****         pow[i] = x;
  59              		.loc 1 77 9 is_stmt 1 view .LVU11
  60              		.loc 1 78 16 is_stmt 0 view .LVU12
  61 0010 E254     		strb	r2, [r4, r3]
  79:simpleserial-glitch.c ****         x ^= XTIME(x);       
  62              		.loc 1 79 14 view .LVU13
  63 0012 43F30606 		sbfx	r6, r3, #0, #7
  77:simpleserial-glitch.c ****         pow[i] = x;
  64              		.loc 1 77 16 view .LVU14
  65 0016 00F8013B 		strb	r3, [r0], #1
  78:simpleserial-glitch.c ****         x ^= XTIME(x);       
  66              		.loc 1 78 9 is_stmt 1 view .LVU15
  67              		.loc 1 79 9 view .LVU16
  68              		.loc 1 79 14 is_stmt 0 view .LVU17
  69 001a 5BB2     		sxtb	r3, r3
  70              	.LVL2:
  71              		.loc 1 79 14 view .LVU18
  72 001c 002B     		cmp	r3, #0
  73 001e B4BF     		ite	lt
  74 0020 1B21     		movlt	r1, #27
  75 0022 0021     		movge	r1, #0
  76              	.LVL3:
  77              		.loc 1 79 11 view .LVU19
  78 0024 83EA4603 		eor	r3, r3, r6, lsl #1
  76:simpleserial-glitch.c ****         pow[i] = x;
  79              		.loc 1 76 34 view .LVU20
  80 0028 0132     		adds	r2, r2, #1
  81              		.loc 1 79 11 view .LVU21
  82 002a 4B40     		eors	r3, r3, r1
  76:simpleserial-glitch.c ****         pow[i] = x;
  83              		.loc 1 76 5 view .LVU22
  84 002c B2F5807F 		cmp	r2, #256
  85              		.loc 1 79 11 view .LVU23
  86 0030 DBB2     		uxtb	r3, r3
  87              	.LVL4:
  76:simpleserial-glitch.c ****         pow[i] = x;
  88              		.loc 1 76 33 is_stmt 1 view .LVU24
  76:simpleserial-glitch.c ****         pow[i] = x;
  89              		.loc 1 76 24 view .LVU25
  76:simpleserial-glitch.c ****         pow[i] = x;
  90              		.loc 1 76 5 is_stmt 0 view .LVU26
  91 0032 EDD1     		bne	.L3
  92 0034 3949     		ldr	r1, .L16
  80:simpleserial-glitch.c ****     }
  81:simpleserial-glitch.c **** 
  82:simpleserial-glitch.c ****     /*
  83:simpleserial-glitch.c ****      * calculate the round constants
  84:simpleserial-glitch.c ****      */
  85:simpleserial-glitch.c ****     for (i = 0, x = 1; i < 10; i++) {
  93              		.loc 1 85 19 view .LVU27
  94 0036 0123     		movs	r3, #1
  95              	.LVL5:
  96              		.loc 1 85 12 view .LVU28
  97 0038 0022     		movs	r2, #0
  98              	.LVL6:
  99              		.loc 1 85 12 view .LVU29
 100 003a 0846     		mov	r0, r1
 101              	.L5:
 102              	.LVL7:
  86:simpleserial-glitch.c ****         round_constants[i] = x;
 103              		.loc 1 86 9 is_stmt 1 view .LVU30
  87:simpleserial-glitch.c ****         x = XTIME(x);
 104              		.loc 1 87 13 is_stmt 0 view .LVU31
 105 003c 13F0800F 		tst	r3, #128
  86:simpleserial-glitch.c ****         round_constants[i] = x;
 106              		.loc 1 86 28 view .LVU32
 107 0040 41F8043B 		str	r3, [r1], #4
 108              		.loc 1 87 9 is_stmt 1 view .LVU33
 109              		.loc 1 87 13 is_stmt 0 view .LVU34
 110 0044 43F30606 		sbfx	r6, r3, #0, #7
  85:simpleserial-glitch.c ****         round_constants[i] = x;
 111              		.loc 1 85 33 view .LVU35
 112 0048 02F10102 		add	r2, r2, #1
 113              	.LVL8:
 114              		.loc 1 87 13 view .LVU36
 115 004c 14BF     		ite	ne
 116 004e 1B23     		movne	r3, #27
 117              	.LVL9:
 118              		.loc 1 87 13 view .LVU37
 119 0050 0023     		moveq	r3, #0
 120 0052 83EA4603 		eor	r3, r3, r6, lsl #1
  85:simpleserial-glitch.c ****         round_constants[i] = x;
 121              		.loc 1 85 5 view .LVU38
 122 0056 0A2A     		cmp	r2, #10
 123              		.loc 1 87 11 view .LVU39
 124 0058 DBB2     		uxtb	r3, r3
 125              	.LVL10:
  85:simpleserial-glitch.c ****         round_constants[i] = x;
 126              		.loc 1 85 32 is_stmt 1 view .LVU40
  85:simpleserial-glitch.c ****         round_constants[i] = x;
 127              		.loc 1 85 24 view .LVU41
  85:simpleserial-glitch.c ****         round_constants[i] = x;
 128              		.loc 1 85 5 is_stmt 0 view .LVU42
 129 005a EFD1     		bne	.L5
  88:simpleserial-glitch.c ****     }
  89:simpleserial-glitch.c **** 
  90:simpleserial-glitch.c ****     /*
  91:simpleserial-glitch.c ****      * generate the forward and reverse S-boxes
  92:simpleserial-glitch.c ****      */
  93:simpleserial-glitch.c ****     FSb[0x00] = 0x63;
 130              		.loc 1 93 5 is_stmt 1 view .LVU43
 131              		.loc 1 93 15 is_stmt 0 view .LVU44
 132 005c 6323     		movs	r3, #99
 133              	.LVL11:
 134              		.loc 1 93 15 view .LVU45
 135 005e 80F82830 		strb	r3, [r0, #40]
  94:simpleserial-glitch.c **** #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)
  95:simpleserial-glitch.c ****     RSb[0x63] = 0x00;
  96:simpleserial-glitch.c **** #endif
  97:simpleserial-glitch.c ****     trigger_high();
 136              		.loc 1 97 5 is_stmt 1 view .LVU46
 137 0062 FFF7FEFF 		bl	trigger_high
 138              	.LVL12:
  98:simpleserial-glitch.c ****     for (i = 1; i < 256; i++) {
 139              		.loc 1 98 5 view .LVU47
 140              		.loc 1 98 17 view .LVU48
  99:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 100:simpleserial-glitch.c **** 
 101:simpleserial-glitch.c ****         y  = x; y = (y << 1) | (y >> 7);
 102:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 103:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 104:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 105:simpleserial-glitch.c ****         x ^= y ^ 0x63;
 106:simpleserial-glitch.c **** 
 107:simpleserial-glitch.c ****         FSb[i] = x;
 141              		.loc 1 107 16 is_stmt 0 view .LVU49
 142 0066 2E48     		ldr	r0, .L16+4
  98:simpleserial-glitch.c ****     for (i = 1; i < 256; i++) {
 143              		.loc 1 98 12 view .LVU50
 144 0068 0122     		movs	r2, #1
 145              	.LVL13:
 146              	.L6:
  99:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 147              		.loc 1 99 9 is_stmt 1 discriminator 3 view .LVU51
  99:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 148              		.loc 1 99 26 is_stmt 0 discriminator 3 view .LVU52
 149 006a A35C     		ldrb	r3, [r4, r2]	@ zero_extendqisi2
  99:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 150              		.loc 1 99 21 discriminator 3 view .LVU53
 151 006c C3F1FF03 		rsb	r3, r3, #255
  99:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 152              		.loc 1 99 11 discriminator 3 view .LVU54
 153 0070 E95C     		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 154              	.LVL14:
 101:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 155              		.loc 1 101 9 is_stmt 1 discriminator 3 view .LVU55
 101:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 156              		.loc 1 101 17 discriminator 3 view .LVU56
 101:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 157              		.loc 1 101 30 is_stmt 0 discriminator 3 view .LVU57
 158 0072 CB09     		lsrs	r3, r1, #7
 159 0074 43EA4103 		orr	r3, r3, r1, lsl #1
 101:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 160              		.loc 1 101 19 discriminator 3 view .LVU58
 161 0078 DEB2     		uxtb	r6, r3
 162              	.LVL15:
 102:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 163              		.loc 1 102 9 is_stmt 1 discriminator 3 view .LVU59
 102:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 164              		.loc 1 102 17 discriminator 3 view .LVU60
 102:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 165              		.loc 1 102 30 is_stmt 0 discriminator 3 view .LVU61
 166 007a C3F3C013 		ubfx	r3, r3, #7, #1
 167 007e 43EA4603 		orr	r3, r3, r6, lsl #1
 102:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 168              		.loc 1 102 19 discriminator 3 view .LVU62
 169 0082 5FFA83FC 		uxtb	ip, r3
 170              	.LVL16:
 103:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 171              		.loc 1 103 9 is_stmt 1 discriminator 3 view .LVU63
 103:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 172              		.loc 1 103 17 discriminator 3 view .LVU64
 103:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 173              		.loc 1 103 30 is_stmt 0 discriminator 3 view .LVU65
 174 0086 C3F3C013 		ubfx	r3, r3, #7, #1
 175 008a 43EA4C03 		orr	r3, r3, ip, lsl #1
 103:simpleserial-glitch.c ****         x ^= y; y = (y << 1) | (y >> 7);
 176              		.loc 1 103 19 discriminator 3 view .LVU66
 177 008e DFB2     		uxtb	r7, r3
 178              	.LVL17:
 104:simpleserial-glitch.c ****         x ^= y ^ 0x63;
 179              		.loc 1 104 9 is_stmt 1 discriminator 3 view .LVU67
 104:simpleserial-glitch.c ****         x ^= y ^ 0x63;
 180              		.loc 1 104 17 discriminator 3 view .LVU68
 104:simpleserial-glitch.c ****         x ^= y ^ 0x63;
 181              		.loc 1 104 30 is_stmt 0 discriminator 3 view .LVU69
 182 0090 C3F3C013 		ubfx	r3, r3, #7, #1
 183 0094 43EA4703 		orr	r3, r3, r7, lsl #1
 184 0098 5BB2     		sxtb	r3, r3
 185              	.LVL18:
 105:simpleserial-glitch.c **** 
 186              		.loc 1 105 9 is_stmt 1 discriminator 3 view .LVU70
 105:simpleserial-glitch.c **** 
 187              		.loc 1 105 11 is_stmt 0 discriminator 3 view .LVU71
 188 009a 4B40     		eors	r3, r3, r1
 189              	.LVL19:
 105:simpleserial-glitch.c **** 
 190              		.loc 1 105 11 discriminator 3 view .LVU72
 191 009c 7340     		eors	r3, r3, r6
 192 009e 8CEA030C 		eor	ip, ip, r3
 193              	.LVL20:
 105:simpleserial-glitch.c **** 
 194              		.loc 1 105 11 discriminator 3 view .LVU73
 195 00a2 87EA0C07 		eor	r7, r7, ip
 196              	.LVL21:
 197              		.loc 1 107 9 is_stmt 1 discriminator 3 view .LVU74
 105:simpleserial-glitch.c **** 
 198              		.loc 1 105 11 is_stmt 0 discriminator 3 view .LVU75
 199 00a6 87F06307 		eor	r7, r7, #99
 200              	.LVL22:
 201              		.loc 1 107 16 discriminator 3 view .LVU76
 202 00aa 8754     		strb	r7, [r0, r2]
  98:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 203              		.loc 1 98 26 is_stmt 1 discriminator 3 view .LVU77
  98:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 204              		.loc 1 98 27 is_stmt 0 discriminator 3 view .LVU78
 205 00ac 0132     		adds	r2, r2, #1
 206              	.LVL23:
  98:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 207              		.loc 1 98 17 is_stmt 1 discriminator 3 view .LVU79
  98:simpleserial-glitch.c ****         x = pow[255 - log[i]];
 208              		.loc 1 98 5 is_stmt 0 discriminator 3 view .LVU80
 209 00ae B2F5807F 		cmp	r2, #256
 210 00b2 DAD1     		bne	.L6
 108:simpleserial-glitch.c **** #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)
 109:simpleserial-glitch.c ****         RSb[x] = (unsigned char) i;
 110:simpleserial-glitch.c **** #endif
 111:simpleserial-glitch.c ****     }
 112:simpleserial-glitch.c ****     trigger_low();
 211              		.loc 1 112 5 is_stmt 1 view .LVU81
 212 00b4 FFF7FEFF 		bl	trigger_low
 213              	.LVL24:
 113:simpleserial-glitch.c **** 
 114:simpleserial-glitch.c ****     /*
 115:simpleserial-glitch.c ****      * generate the forward and reverse tables
 116:simpleserial-glitch.c ****      */
 117:simpleserial-glitch.c ****     for (i = 0; i < 256; i++) {
 214              		.loc 1 117 5 view .LVU82
 215              		.loc 1 117 17 view .LVU83
 216 00b8 1948     		ldr	r0, .L16+4
 217              		.loc 1 117 12 is_stmt 0 view .LVU84
 218 00ba 0024     		movs	r4, #0
 219 00bc 00F5807C 		add	ip, r0, #256
 220 00c0 00F5A067 		add	r7, r0, #1280
 221              	.LVL25:
 222              		.loc 1 117 12 view .LVU85
 223 00c4 00F51066 		add	r6, r0, #2304
 224              		.loc 1 117 12 view .LVU86
 225 00c8 00F55065 		add	r5, r0, #3328
 226              	.LVL26:
 227              	.L8:
 118:simpleserial-glitch.c ****         x = FSb[i];
 228              		.loc 1 118 9 is_stmt 1 view .LVU87
 229              		.loc 1 118 11 is_stmt 0 view .LVU88
 230 00cc 10F8012B 		ldrb	r2, [r0], #1	@ zero_extendqisi2
 231              	.LVL27:
 119:simpleserial-glitch.c ****         y = XTIME(x);
 232              		.loc 1 119 9 is_stmt 1 view .LVU89
 233              		.loc 1 119 13 is_stmt 0 view .LVU90
 234 00d0 12F0800F 		tst	r2, #128
 235 00d4 42F30603 		sbfx	r3, r2, #0, #7
 236 00d8 14BF     		ite	ne
 237 00da 1B21     		movne	r1, #27
 238 00dc 0021     		moveq	r1, #0
 239 00de 81EA4301 		eor	r1, r1, r3, lsl #1
 120:simpleserial-glitch.c ****         z = y ^ x;
 121:simpleserial-glitch.c **** 
 122:simpleserial-glitch.c ****         FT0[i] = ((uint32_t) y) ^
 123:simpleserial-glitch.c ****                  ((uint32_t) x <<  8) ^
 124:simpleserial-glitch.c ****                  ((uint32_t) x << 16) ^
 240              		.loc 1 124 32 view .LVU91
 241 00e2 1304     		lsls	r3, r2, #16
 119:simpleserial-glitch.c ****         y = XTIME(x);
 242              		.loc 1 119 11 view .LVU92
 243 00e4 C9B2     		uxtb	r1, r1
 244              	.LVL28:
 120:simpleserial-glitch.c ****         z = y ^ x;
 245              		.loc 1 120 9 is_stmt 1 view .LVU93
 122:simpleserial-glitch.c ****                  ((uint32_t) x <<  8) ^
 246              		.loc 1 122 9 view .LVU94
 123:simpleserial-glitch.c ****                  ((uint32_t) x << 16) ^
 247              		.loc 1 123 39 is_stmt 0 view .LVU95
 248 00e6 43EA0223 		orr	r3, r3, r2, lsl #8
 249 00ea 4B40     		eors	r3, r3, r1
 125:simpleserial-glitch.c ****                  ((uint32_t) z << 24);
 250              		.loc 1 125 19 view .LVU96
 251 00ec 4A40     		eors	r2, r2, r1
 252              	.LVL29:
 124:simpleserial-glitch.c ****                  ((uint32_t) z << 24);
 253              		.loc 1 124 39 view .LVU97
 254 00ee 43EA0263 		orr	r3, r3, r2, lsl #24
 126:simpleserial-glitch.c **** 
 127:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_FEWER_TABLES)
 128:simpleserial-glitch.c ****         FT1[i] = ROTL8(FT0[i]);
 255              		.loc 1 128 18 view .LVU98
 256 00f2 4FEA3362 		ror	r2, r3, #24
 117:simpleserial-glitch.c ****         x = FSb[i];
 257              		.loc 1 117 27 view .LVU99
 258 00f6 0134     		adds	r4, r4, #1
 259              	.LVL30:
 122:simpleserial-glitch.c ****                  ((uint32_t) x <<  8) ^
 260              		.loc 1 122 16 view .LVU100
 261 00f8 4CF8043B 		str	r3, [ip], #4
 262              		.loc 1 128 9 is_stmt 1 view .LVU101
 263              		.loc 1 128 16 is_stmt 0 view .LVU102
 264 00fc 47F8042B 		str	r2, [r7], #4
 129:simpleserial-glitch.c ****         FT2[i] = ROTL8(FT1[i]);
 265              		.loc 1 129 9 is_stmt 1 view .LVU103
 117:simpleserial-glitch.c ****         x = FSb[i];
 266              		.loc 1 117 5 is_stmt 0 view .LVU104
 267 0100 B4F5807F 		cmp	r4, #256
 268              		.loc 1 129 18 view .LVU105
 269 0104 4FEA3342 		ror	r2, r3, #16
 130:simpleserial-glitch.c ****         FT3[i] = ROTL8(FT2[i]);
 270              		.loc 1 130 18 view .LVU106
 271 0108 4FEA3323 		ror	r3, r3, #8
 129:simpleserial-glitch.c ****         FT2[i] = ROTL8(FT1[i]);
 272              		.loc 1 129 16 view .LVU107
 273 010c 46F8042B 		str	r2, [r6], #4
 274              		.loc 1 130 9 is_stmt 1 view .LVU108
 275              		.loc 1 130 16 is_stmt 0 view .LVU109
 276 0110 45F8043B 		str	r3, [r5], #4
 117:simpleserial-glitch.c ****         x = FSb[i];
 277              		.loc 1 117 26 is_stmt 1 view .LVU110
 278              	.LVL31:
 117:simpleserial-glitch.c ****         x = FSb[i];
 279              		.loc 1 117 17 view .LVU111
 117:simpleserial-glitch.c ****         x = FSb[i];
 280              		.loc 1 117 5 is_stmt 0 view .LVU112
 281 0114 DAD1     		bne	.L8
 131:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_FEWER_TABLES */
 132:simpleserial-glitch.c **** 
 133:simpleserial-glitch.c **** #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)
 134:simpleserial-glitch.c ****         x = RSb[i];
 135:simpleserial-glitch.c **** 
 136:simpleserial-glitch.c ****         RT0[i] = ((uint32_t) MUL(0x0E, x)) ^
 137:simpleserial-glitch.c ****                  ((uint32_t) MUL(0x09, x) <<  8) ^
 138:simpleserial-glitch.c ****                  ((uint32_t) MUL(0x0D, x) << 16) ^
 139:simpleserial-glitch.c ****                  ((uint32_t) MUL(0x0B, x) << 24);
 140:simpleserial-glitch.c **** 
 141:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_FEWER_TABLES)
 142:simpleserial-glitch.c ****         RT1[i] = ROTL8(RT0[i]);
 143:simpleserial-glitch.c ****         RT2[i] = ROTL8(RT1[i]);
 144:simpleserial-glitch.c ****         RT3[i] = ROTL8(RT2[i]);
 145:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_FEWER_TABLES */
 146:simpleserial-glitch.c **** #endif /* MBEDTLS_AES_NEED_REVERSE_TABLES */
 147:simpleserial-glitch.c ****     }
 148:simpleserial-glitch.c **** }
 282              		.loc 1 148 1 view .LVU113
 283 0116 0DF5017D 		add	sp, sp, #516
 284              	.LCFI2:
 285              		.cfi_def_cfa_offset 20
 286              		@ sp needed
 287 011a F0BD     		pop	{r4, r5, r6, r7, pc}
 288              	.LVL32:
 289              	.L17:
 290              		.loc 1 148 1 view .LVU114
 291              		.align	2
 292              	.L16:
 293 011c 00000000 		.word	.LANCHOR0
 294 0120 28000000 		.word	.LANCHOR0+40
 295              		.cfi_endproc
 296              	.LFE13:
 298              		.section	.text.mbedtls_platform_zeroize.part.0,"ax",%progbits
 299              		.align	1
 300              		.syntax unified
 301              		.thumb
 302              		.thumb_func
 304              	mbedtls_platform_zeroize.part.0:
 305              	.LVL33:
 306              	.LFB26:
 149:simpleserial-glitch.c **** 
 150:simpleserial-glitch.c **** #undef ROTL8
 151:simpleserial-glitch.c **** 
 152:simpleserial-glitch.c **** #define AES_RT0(idx) RT0[idx]
 153:simpleserial-glitch.c **** #define AES_RT1(idx) RT1[idx]
 154:simpleserial-glitch.c **** #define AES_RT2(idx) RT2[idx]
 155:simpleserial-glitch.c **** #define AES_RT3(idx) RT3[idx]
 156:simpleserial-glitch.c **** 
 157:simpleserial-glitch.c **** #define AES_FT0(idx) FT0[idx]
 158:simpleserial-glitch.c **** #define AES_FT1(idx) FT1[idx]
 159:simpleserial-glitch.c **** #define AES_FT2(idx) FT2[idx]
 160:simpleserial-glitch.c **** #define AES_FT3(idx) FT3[idx]
 161:simpleserial-glitch.c **** 
 162:simpleserial-glitch.c **** unsigned mbedtls_aes_rk_offset(uint32_t *buf)
 163:simpleserial-glitch.c **** {
 164:simpleserial-glitch.c ****     (void) buf;
 165:simpleserial-glitch.c ****     return 0;
 166:simpleserial-glitch.c **** }
 167:simpleserial-glitch.c **** 
 168:simpleserial-glitch.c **** /*
 169:simpleserial-glitch.c ****  * AES key schedule (encryption)
 170:simpleserial-glitch.c ****  */
 171:simpleserial-glitch.c **** uint8_t n_gencalls = 0;
 172:simpleserial-glitch.c **** int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key,
 173:simpleserial-glitch.c ****                            unsigned int keybits)
 174:simpleserial-glitch.c **** {
 175:simpleserial-glitch.c ****     uint32_t *RK;
 176:simpleserial-glitch.c **** 
 177:simpleserial-glitch.c ****     switch (keybits) {
 178:simpleserial-glitch.c ****         case 128: ctx->nr = 10; break;
 179:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
 180:simpleserial-glitch.c ****         case 192: ctx->nr = 12; break;
 181:simpleserial-glitch.c ****         case 256: ctx->nr = 14; break;
 182:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 183:simpleserial-glitch.c ****         default: return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
 184:simpleserial-glitch.c ****     }
 185:simpleserial-glitch.c **** 
 186:simpleserial-glitch.c ****     if (aes_init_done == 0) {
 187:simpleserial-glitch.c ****         n_gencalls++;
 188:simpleserial-glitch.c ****         aes_gen_tables();
 189:simpleserial-glitch.c ****         aes_init_done = 1;
 190:simpleserial-glitch.c ****     }
 191:simpleserial-glitch.c **** 
 192:simpleserial-glitch.c ****     ctx->rk_offset = mbedtls_aes_rk_offset(ctx->buf);
 193:simpleserial-glitch.c ****     RK = ctx->buf + ctx->rk_offset;
 194:simpleserial-glitch.c **** 
 195:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 196:simpleserial-glitch.c ****     for (unsigned int i = 0; i < (keybits >> 5); i++) {
 197:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 198:simpleserial-glitch.c ****     }
 199:simpleserial-glitch.c **** 
 200:simpleserial-glitch.c ****     switch (ctx->nr) {
 201:simpleserial-glitch.c ****         case 10:
 202:simpleserial-glitch.c **** 
 203:simpleserial-glitch.c ****             for (unsigned int i = 0; i < 10; i++, RK += 4) {
 204:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 205:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[3])]) ^
 206:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] <<  8) ^
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[3])] << 16) ^
 208:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 209:simpleserial-glitch.c **** 
 210:simpleserial-glitch.c ****                 RK[5]  = RK[1] ^ RK[4];
 211:simpleserial-glitch.c ****                 RK[6]  = RK[2] ^ RK[5];
 212:simpleserial-glitch.c ****                 RK[7]  = RK[3] ^ RK[6];
 213:simpleserial-glitch.c ****             }
 214:simpleserial-glitch.c ****             break;
 215:simpleserial-glitch.c **** 
 216:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
 217:simpleserial-glitch.c ****         case 12:
 218:simpleserial-glitch.c **** 
 219:simpleserial-glitch.c ****             for (unsigned int i = 0; i < 8; i++, RK += 6) {
 220:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 221:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[5])]) ^
 222:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] <<  8) ^
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[5])] << 16) ^
 224:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 225:simpleserial-glitch.c **** 
 226:simpleserial-glitch.c ****                 RK[7]  = RK[1] ^ RK[6];
 227:simpleserial-glitch.c ****                 RK[8]  = RK[2] ^ RK[7];
 228:simpleserial-glitch.c ****                 RK[9]  = RK[3] ^ RK[8];
 229:simpleserial-glitch.c ****                 RK[10] = RK[4] ^ RK[9];
 230:simpleserial-glitch.c ****                 RK[11] = RK[5] ^ RK[10];
 231:simpleserial-glitch.c ****             }
 232:simpleserial-glitch.c ****             break;
 233:simpleserial-glitch.c **** 
 234:simpleserial-glitch.c ****         case 14:
 235:simpleserial-glitch.c **** 
 236:simpleserial-glitch.c ****             for (unsigned int i = 0; i < 7; i++, RK += 8) {
 237:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 238:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[7])]) ^
 239:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] <<  8) ^
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[7])] << 16) ^
 241:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 242:simpleserial-glitch.c **** 
 243:simpleserial-glitch.c ****                 RK[9]  = RK[1] ^ RK[8];
 244:simpleserial-glitch.c ****                 RK[10] = RK[2] ^ RK[9];
 245:simpleserial-glitch.c ****                 RK[11] = RK[3] ^ RK[10];
 246:simpleserial-glitch.c **** 
 247:simpleserial-glitch.c ****                 RK[12] = RK[4] ^
 248:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[11])]) ^
 249:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[11])] <<  8) ^
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[11])] << 16) ^
 251:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 252:simpleserial-glitch.c **** 
 253:simpleserial-glitch.c ****                 RK[13] = RK[5] ^ RK[12];
 254:simpleserial-glitch.c ****                 RK[14] = RK[6] ^ RK[13];
 255:simpleserial-glitch.c ****                 RK[15] = RK[7] ^ RK[14];
 256:simpleserial-glitch.c ****             }
 257:simpleserial-glitch.c ****             break;
 258:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 259:simpleserial-glitch.c ****     }
 260:simpleserial-glitch.c **** 
 261:simpleserial-glitch.c ****     return 0;
 262:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */
 263:simpleserial-glitch.c **** }
 264:simpleserial-glitch.c **** 
 265:simpleserial-glitch.c **** static void *(*const volatile memset_func)(void *, int, size_t) = memset;
 266:simpleserial-glitch.c **** 
 267:simpleserial-glitch.c **** void mbedtls_aes_init(mbedtls_aes_context *ctx)
 268:simpleserial-glitch.c **** {
 269:simpleserial-glitch.c ****     memset(ctx, 0, sizeof(mbedtls_aes_context));
 270:simpleserial-glitch.c **** }
 271:simpleserial-glitch.c **** 
 272:simpleserial-glitch.c **** void mbedtls_aes_free(mbedtls_aes_context *ctx)
 273:simpleserial-glitch.c **** {
 274:simpleserial-glitch.c ****     if (ctx == NULL) {
 275:simpleserial-glitch.c ****         return;
 276:simpleserial-glitch.c ****     }
 277:simpleserial-glitch.c **** 
 278:simpleserial-glitch.c ****     mbedtls_platform_zeroize(ctx, sizeof(mbedtls_aes_context));
 279:simpleserial-glitch.c **** }
 280:simpleserial-glitch.c **** 
 281:simpleserial-glitch.c **** void mbedtls_platform_zeroize(void *buf, size_t len)
 307              		.loc 1 281 6 is_stmt 1 view -0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 282:simpleserial-glitch.c **** {
 283:simpleserial-glitch.c ****     if (len > 0) {
 284:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 311              		.loc 1 284 9 is_stmt 0 view .LVU116
 312 0000 034B     		ldr	r3, .L19
 281:simpleserial-glitch.c **** {
 313              		.loc 1 281 6 view .LVU117
 314 0002 10B5     		push	{r4, lr}
 315              	.LCFI3:
 316              		.cfi_def_cfa_offset 8
 317              		.cfi_offset 4, -8
 318              		.cfi_offset 14, -4
 281:simpleserial-glitch.c **** {
 319              		.loc 1 281 6 view .LVU118
 320 0004 0A46     		mov	r2, r1
 321              		.loc 1 284 9 is_stmt 1 view .LVU119
 322 0006 1B68     		ldr	r3, [r3]
 323 0008 0021     		movs	r1, #0
 324              	.LVL34:
 281:simpleserial-glitch.c **** {
 325              		.loc 1 281 6 is_stmt 0 view .LVU120
 326 000a 0446     		mov	r4, r0
 327              		.loc 1 284 9 view .LVU121
 328 000c 9847     		blx	r3
 329              	.LVL35:
 285:simpleserial-glitch.c **** #if defined(__GNUC__)
 286:simpleserial-glitch.c ****         /* For clang and recent gcc, pretend that we have some assembly that reads the
 287:simpleserial-glitch.c ****          * zero'd memory as an additional protection against being optimised away. */
 288:simpleserial-glitch.c **** #if defined(__clang__) || (__GNUC__ >= 10)
 289:simpleserial-glitch.c **** #if defined(__clang__)
 290:simpleserial-glitch.c **** #pragma clang diagnostic push
 291:simpleserial-glitch.c **** #pragma clang diagnostic ignored "-Wvla"
 292:simpleserial-glitch.c **** #elif defined(MBEDTLS_COMPILER_IS_GCC)
 293:simpleserial-glitch.c **** #pragma GCC diagnostic push
 294:simpleserial-glitch.c **** #pragma GCC diagnostic ignored "-Wvla"
 295:simpleserial-glitch.c **** #endif
 296:simpleserial-glitch.c ****         asm volatile ("" : : "m" (*(char (*)[len]) buf) :);
 330              		.loc 1 296 9 is_stmt 1 view .LVU122
 331              		.loc 1 296 9 is_stmt 0 view .LVU123
 297:simpleserial-glitch.c **** #if defined(__clang__)
 298:simpleserial-glitch.c **** #pragma clang diagnostic pop
 299:simpleserial-glitch.c **** #elif defined(MBEDTLS_COMPILER_IS_GCC)
 300:simpleserial-glitch.c **** #pragma GCC diagnostic pop
 301:simpleserial-glitch.c **** #endif
 302:simpleserial-glitch.c **** #endif
 303:simpleserial-glitch.c **** #endif
 304:simpleserial-glitch.c ****     }
 305:simpleserial-glitch.c **** }
 332              		.loc 1 305 1 view .LVU124
 333 000e 10BD     		pop	{r4, pc}
 334              	.LVL36:
 335              	.L20:
 336              		.loc 1 305 1 view .LVU125
 337              		.align	2
 338              	.L19:
 339 0010 00000000 		.word	.LANCHOR1
 340              		.cfi_endproc
 341              	.LFE26:
 343              		.section	.text.mbedtls_aes_rk_offset,"ax",%progbits
 344              		.align	1
 345              		.global	mbedtls_aes_rk_offset
 346              		.syntax unified
 347              		.thumb
 348              		.thumb_func
 350              	mbedtls_aes_rk_offset:
 351              	.LVL37:
 352              	.LFB14:
 163:simpleserial-glitch.c ****     (void) buf;
 353              		.loc 1 163 1 is_stmt 1 view -0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              		@ link register save eliminated.
 164:simpleserial-glitch.c ****     return 0;
 358              		.loc 1 164 5 view .LVU127
 165:simpleserial-glitch.c **** }
 359              		.loc 1 165 5 view .LVU128
 166:simpleserial-glitch.c **** 
 360              		.loc 1 166 1 is_stmt 0 view .LVU129
 361 0000 0020     		movs	r0, #0
 362              	.LVL38:
 166:simpleserial-glitch.c **** 
 363              		.loc 1 166 1 view .LVU130
 364 0002 7047     		bx	lr
 365              		.cfi_endproc
 366              	.LFE14:
 368              		.section	.text.mbedtls_aes_setkey_enc,"ax",%progbits
 369              		.align	1
 370              		.global	mbedtls_aes_setkey_enc
 371              		.syntax unified
 372              		.thumb
 373              		.thumb_func
 375              	mbedtls_aes_setkey_enc:
 376              	.LVL39:
 377              	.LFB15:
 174:simpleserial-glitch.c ****     uint32_t *RK;
 378              		.loc 1 174 1 is_stmt 1 view -0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 0
 381              		@ frame_needed = 0, uses_anonymous_args = 0
 175:simpleserial-glitch.c **** 
 382              		.loc 1 175 5 view .LVU132
 177:simpleserial-glitch.c ****         case 128: ctx->nr = 10; break;
 383              		.loc 1 177 5 view .LVU133
 384 0000 C02A     		cmp	r2, #192
 174:simpleserial-glitch.c ****     uint32_t *RK;
 385              		.loc 1 174 1 is_stmt 0 view .LVU134
 386 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 387              	.LCFI4:
 388              		.cfi_def_cfa_offset 24
 389              		.cfi_offset 3, -24
 390              		.cfi_offset 4, -20
 391              		.cfi_offset 5, -16
 392              		.cfi_offset 6, -12
 393              		.cfi_offset 7, -8
 394              		.cfi_offset 14, -4
 174:simpleserial-glitch.c ****     uint32_t *RK;
 395              		.loc 1 174 1 view .LVU135
 396 0004 0546     		mov	r5, r0
 397 0006 0E46     		mov	r6, r1
 398 0008 1446     		mov	r4, r2
 177:simpleserial-glitch.c ****         case 128: ctx->nr = 10; break;
 399              		.loc 1 177 5 view .LVU136
 400 000a 56D0     		beq	.L23
 401 000c B2F5807F 		cmp	r2, #256
 402 0010 55D0     		beq	.L24
 403 0012 802A     		cmp	r2, #128
 404 0014 40F0EB80 		bne	.L36
 178:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
 405              		.loc 1 178 19 is_stmt 1 view .LVU137
 178:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
 406              		.loc 1 178 27 is_stmt 0 view .LVU138
 407 0018 0A23     		movs	r3, #10
 408              	.L41:
 186:simpleserial-glitch.c ****         n_gencalls++;
 409              		.loc 1 186 23 view .LVU139
 410 001a 764F     		ldr	r7, .L42
 181:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 411              		.loc 1 181 27 view .LVU140
 412 001c 2B60     		str	r3, [r5]
 181:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 413              		.loc 1 181 33 is_stmt 1 view .LVU141
 186:simpleserial-glitch.c ****         n_gencalls++;
 414              		.loc 1 186 5 view .LVU142
 186:simpleserial-glitch.c ****         n_gencalls++;
 415              		.loc 1 186 8 is_stmt 0 view .LVU143
 416 001e 3B6B     		ldr	r3, [r7, #48]
 417 0020 43B9     		cbnz	r3, .L27
 187:simpleserial-glitch.c ****         aes_gen_tables();
 418              		.loc 1 187 9 is_stmt 1 view .LVU144
 187:simpleserial-glitch.c ****         aes_gen_tables();
 419              		.loc 1 187 19 is_stmt 0 view .LVU145
 420 0022 97F83430 		ldrb	r3, [r7, #52]	@ zero_extendqisi2
 421 0026 0133     		adds	r3, r3, #1
 422 0028 87F83430 		strb	r3, [r7, #52]
 188:simpleserial-glitch.c ****         aes_init_done = 1;
 423              		.loc 1 188 9 is_stmt 1 view .LVU146
 424 002c FFF7FEFF 		bl	aes_gen_tables
 425              	.LVL40:
 189:simpleserial-glitch.c ****     }
 426              		.loc 1 189 9 view .LVU147
 189:simpleserial-glitch.c ****     }
 427              		.loc 1 189 23 is_stmt 0 view .LVU148
 428 0030 0123     		movs	r3, #1
 429 0032 3B63     		str	r3, [r7, #48]
 430              	.L27:
 192:simpleserial-glitch.c ****     RK = ctx->buf + ctx->rk_offset;
 431              		.loc 1 192 5 is_stmt 1 view .LVU149
 432              	.LVL41:
 164:simpleserial-glitch.c ****     return 0;
 433              		.loc 1 164 5 view .LVU150
 165:simpleserial-glitch.c **** }
 434              		.loc 1 165 5 view .LVU151
 192:simpleserial-glitch.c ****     RK = ctx->buf + ctx->rk_offset;
 435              		.loc 1 192 20 is_stmt 0 view .LVU152
 436 0034 0023     		movs	r3, #0
 437              	.LBB107:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 438              		.loc 1 196 43 view .LVU153
 439 0036 6409     		lsrs	r4, r4, #5
 440              	.LVL42:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 441              		.loc 1 196 43 view .LVU154
 442              	.LBE107:
 192:simpleserial-glitch.c ****     RK = ctx->buf + ctx->rk_offset;
 443              		.loc 1 192 20 view .LVU155
 444 0038 6B60     		str	r3, [r5, #4]
 193:simpleserial-glitch.c **** 
 445              		.loc 1 193 5 is_stmt 1 view .LVU156
 446              	.LVL43:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 447              		.loc 1 196 5 view .LVU157
 448              	.LBB108:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 449              		.loc 1 196 10 view .LVU158
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 450              		.loc 1 196 10 is_stmt 0 view .LVU159
 451 003a 3146     		mov	r1, r6
 452 003c 05F10803 		add	r3, r5, #8
 453              	.LVL44:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 454              		.loc 1 196 10 view .LVU160
 455 0040 06EB8404 		add	r4, r6, r4, lsl #2
 456              	.LVL45:
 457              	.L28:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 458              		.loc 1 196 30 is_stmt 1 discriminator 1 view .LVU161
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 459              		.loc 1 196 5 is_stmt 0 discriminator 1 view .LVU162
 460 0044 8C42     		cmp	r4, r1
 461 0046 3CD1     		bne	.L29
 462              	.LBE108:
 200:simpleserial-glitch.c ****         case 10:
 463              		.loc 1 200 5 is_stmt 1 view .LVU163
 200:simpleserial-glitch.c ****         case 10:
 464              		.loc 1 200 16 is_stmt 0 view .LVU164
 465 0048 2B68     		ldr	r3, [r5]
 200:simpleserial-glitch.c ****         case 10:
 466              		.loc 1 200 5 view .LVU165
 467 004a 0C2B     		cmp	r3, #12
 468 004c 3ED0     		beq	.L30
 469 004e 0E2B     		cmp	r3, #14
 470 0050 75D0     		beq	.L31
 471 0052 0A2B     		cmp	r3, #10
 472 0054 2FD1     		bne	.L37
 473 0056 2846     		mov	r0, r5
 474 0058 674D     		ldr	r5, .L42+4
 475              	.LVL46:
 200:simpleserial-glitch.c ****         case 10:
 476              		.loc 1 200 5 view .LVU166
 477 005a 00F1A006 		add	r6, r0, #160
 478              	.LVL47:
 200:simpleserial-glitch.c ****         case 10:
 479              		.loc 1 200 5 view .LVU167
 480 005e 2946     		mov	r1, r5
 481              	.LVL48:
 482              	.L32:
 483              	.LBB109:
 204:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[3])]) ^
 484              		.loc 1 204 17 is_stmt 1 discriminator 3 view .LVU168
 205:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] <<  8) ^
 485              		.loc 1 205 42 is_stmt 0 discriminator 3 view .LVU169
 486 0060 4269     		ldr	r2, [r0, #20]
 204:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[3])]) ^
 487              		.loc 1 204 49 discriminator 3 view .LVU170
 488 0062 55F8044B 		ldr	r4, [r5], #4
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 489              		.loc 1 207 72 discriminator 3 view .LVU171
 490 0066 8768     		ldr	r7, [r0, #8]
 205:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] <<  8) ^
 491              		.loc 1 205 42 discriminator 3 view .LVU172
 492 0068 C2F30723 		ubfx	r3, r2, #8, #8
 205:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] <<  8) ^
 493              		.loc 1 205 41 discriminator 3 view .LVU173
 494 006c 0B44     		add	r3, r3, r1
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 495              		.loc 1 207 72 discriminator 3 view .LVU174
 496 006e 7C40     		eors	r4, r4, r7
 205:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] <<  8) ^
 497              		.loc 1 205 27 discriminator 3 view .LVU175
 498 0070 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 499              		.loc 1 207 72 discriminator 3 view .LVU176
 500 0074 6340     		eors	r3, r3, r4
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 501              		.loc 1 207 41 discriminator 3 view .LVU177
 502 0076 01EB1264 		add	r4, r1, r2, lsr #24
 203:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 503              		.loc 1 203 13 discriminator 3 view .LVU178
 504 007a 1030     		adds	r0, r0, #16
 505              	.LVL49:
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 506              		.loc 1 207 27 discriminator 3 view .LVU179
 507 007c 94F82840 		ldrb	r4, [r4, #40]	@ zero_extendqisi2
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 508              		.loc 1 207 72 discriminator 3 view .LVU180
 509 0080 83EA0443 		eor	r3, r3, r4, lsl #16
 208:simpleserial-glitch.c **** 
 510              		.loc 1 208 41 discriminator 3 view .LVU181
 511 0084 51FA82F4 		uxtab	r4, r1, r2
 208:simpleserial-glitch.c **** 
 512              		.loc 1 208 27 discriminator 3 view .LVU182
 513 0088 94F82840 		ldrb	r4, [r4, #40]	@ zero_extendqisi2
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 514              		.loc 1 207 72 discriminator 3 view .LVU183
 515 008c 83EA0463 		eor	r3, r3, r4, lsl #24
 206:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[3])] << 16) ^
 516              		.loc 1 206 42 discriminator 3 view .LVU184
 517 0090 C2F30744 		ubfx	r4, r2, #16, #8
 206:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[3])] << 16) ^
 518              		.loc 1 206 41 discriminator 3 view .LVU185
 519 0094 0C44     		add	r4, r4, r1
 206:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[3])] << 16) ^
 520              		.loc 1 206 27 discriminator 3 view .LVU186
 521 0096 94F82840 		ldrb	r4, [r4, #40]	@ zero_extendqisi2
 207:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] << 24);
 522              		.loc 1 207 72 discriminator 3 view .LVU187
 523 009a 83EA0423 		eor	r3, r3, r4, lsl #8
 210:simpleserial-glitch.c ****                 RK[6]  = RK[2] ^ RK[5];
 524              		.loc 1 210 32 discriminator 3 view .LVU188
 525 009e 50F8044C 		ldr	r4, [r0, #-4]
 204:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[3])]) ^
 526              		.loc 1 204 24 discriminator 3 view .LVU189
 527 00a2 8360     		str	r3, [r0, #8]
 210:simpleserial-glitch.c ****                 RK[6]  = RK[2] ^ RK[5];
 528              		.loc 1 210 17 is_stmt 1 discriminator 3 view .LVU190
 210:simpleserial-glitch.c ****                 RK[6]  = RK[2] ^ RK[5];
 529              		.loc 1 210 32 is_stmt 0 discriminator 3 view .LVU191
 530 00a4 6340     		eors	r3, r3, r4
 211:simpleserial-glitch.c ****                 RK[7]  = RK[3] ^ RK[6];
 531              		.loc 1 211 32 discriminator 3 view .LVU192
 532 00a6 0468     		ldr	r4, [r0]
 210:simpleserial-glitch.c ****                 RK[6]  = RK[2] ^ RK[5];
 533              		.loc 1 210 24 discriminator 3 view .LVU193
 534 00a8 C360     		str	r3, [r0, #12]
 211:simpleserial-glitch.c ****                 RK[7]  = RK[3] ^ RK[6];
 535              		.loc 1 211 17 is_stmt 1 discriminator 3 view .LVU194
 211:simpleserial-glitch.c ****                 RK[7]  = RK[3] ^ RK[6];
 536              		.loc 1 211 32 is_stmt 0 discriminator 3 view .LVU195
 537 00aa 6340     		eors	r3, r3, r4
 211:simpleserial-glitch.c ****                 RK[7]  = RK[3] ^ RK[6];
 538              		.loc 1 211 24 discriminator 3 view .LVU196
 539 00ac 0361     		str	r3, [r0, #16]
 212:simpleserial-glitch.c ****             }
 540              		.loc 1 212 17 is_stmt 1 discriminator 3 view .LVU197
 212:simpleserial-glitch.c ****             }
 541              		.loc 1 212 32 is_stmt 0 discriminator 3 view .LVU198
 542 00ae 5340     		eors	r3, r3, r2
 212:simpleserial-glitch.c ****             }
 543              		.loc 1 212 24 discriminator 3 view .LVU199
 544 00b0 4361     		str	r3, [r0, #20]
 203:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 545              		.loc 1 203 46 is_stmt 1 discriminator 3 view .LVU200
 546              	.LVL50:
 203:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 547              		.loc 1 203 38 discriminator 3 view .LVU201
 203:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 548              		.loc 1 203 13 is_stmt 0 discriminator 3 view .LVU202
 549 00b2 8642     		cmp	r6, r0
 550 00b4 D4D1     		bne	.L32
 551              	.LVL51:
 552              	.L37:
 203:simpleserial-glitch.c ****                 RK[4]  = RK[0] ^ round_constants[i] ^
 553              		.loc 1 203 13 discriminator 3 view .LVU203
 554              	.LBE109:
 200:simpleserial-glitch.c ****         case 10:
 555              		.loc 1 200 5 view .LVU204
 556 00b6 0020     		movs	r0, #0
 557 00b8 9BE0     		b	.L22
 558              	.LVL52:
 559              	.L23:
 180:simpleserial-glitch.c ****         case 256: ctx->nr = 14; break;
 560              		.loc 1 180 19 is_stmt 1 view .LVU205
 180:simpleserial-glitch.c ****         case 256: ctx->nr = 14; break;
 561              		.loc 1 180 27 is_stmt 0 view .LVU206
 562 00ba 0C23     		movs	r3, #12
 563 00bc ADE7     		b	.L41
 564              	.L24:
 181:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 565              		.loc 1 181 19 is_stmt 1 view .LVU207
 181:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */
 566              		.loc 1 181 27 is_stmt 0 view .LVU208
 567 00be 0E23     		movs	r3, #14
 568 00c0 ABE7     		b	.L41
 569              	.LVL53:
 570              	.L29:
 571              	.LBB110:
 197:simpleserial-glitch.c ****     }
 572              		.loc 1 197 9 is_stmt 1 discriminator 3 view .LVU209
 197:simpleserial-glitch.c ****     }
 573              		.loc 1 197 9 is_stmt 0 discriminator 3 view .LVU210
 574              	.LBE110:
 575              		.file 2 "alignment.h"
   1:alignment.h   **** /**
   2:alignment.h   ****  * \file alignment.h
   3:alignment.h   ****  *
   4:alignment.h   ****  * \brief Utility code for dealing with unaligned memory accesses
   5:alignment.h   ****  */
   6:alignment.h   **** /*
   7:alignment.h   ****  *  Copyright The Mbed TLS Contributors
   8:alignment.h   ****  *  SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later
   9:alignment.h   ****  */
  10:alignment.h   **** 
  11:alignment.h   **** #ifndef MBEDTLS_LIBRARY_ALIGNMENT_H
  12:alignment.h   **** #define MBEDTLS_LIBRARY_ALIGNMENT_H
  13:alignment.h   **** 
  14:alignment.h   **** #include <stdint.h>
  15:alignment.h   **** #include <string.h>
  16:alignment.h   **** #include <stdlib.h>
  17:alignment.h   **** 
  18:alignment.h   **** /*
  19:alignment.h   ****  * Define MBEDTLS_EFFICIENT_UNALIGNED_ACCESS for architectures where unaligned memory
  20:alignment.h   ****  * accesses are known to be efficient.
  21:alignment.h   ****  *
  22:alignment.h   ****  * All functions defined here will behave correctly regardless, but might be less
  23:alignment.h   ****  * efficient when this is not defined.
  24:alignment.h   ****  */
  25:alignment.h   **** #if defined(__ARM_FEATURE_UNALIGNED) \
  26:alignment.h   ****     || defined(MBEDTLS_ARCH_IS_X86) || defined(MBEDTLS_ARCH_IS_X64) \
  27:alignment.h   ****     || defined(MBEDTLS_PLATFORM_IS_WINDOWS_ON_ARM64)
  28:alignment.h   **** /*
  29:alignment.h   ****  * __ARM_FEATURE_UNALIGNED is defined where appropriate by armcc, gcc 7, clang 9
  30:alignment.h   ****  * (and later versions) for Arm v7 and later; all x86 platforms should have
  31:alignment.h   ****  * efficient unaligned access.
  32:alignment.h   ****  *
  33:alignment.h   ****  * https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170#alignmen
  34:alignment.h   ****  * specifies that on Windows-on-Arm64, unaligned access is safe (except for uncached
  35:alignment.h   ****  * device memory).
  36:alignment.h   ****  */
  37:alignment.h   **** #define MBEDTLS_EFFICIENT_UNALIGNED_ACCESS
  38:alignment.h   **** #endif
  39:alignment.h   **** 
  40:alignment.h   **** #if defined(__IAR_SYSTEMS_ICC__) && \
  41:alignment.h   ****     (defined(MBEDTLS_ARCH_IS_ARM64) || defined(MBEDTLS_ARCH_IS_ARM32) \
  42:alignment.h   ****     || defined(__ICCRX__) || defined(__ICCRL78__) || defined(__ICCRISCV__))
  43:alignment.h   **** #pragma language=save
  44:alignment.h   **** #pragma language=extended
  45:alignment.h   **** #define MBEDTLS_POP_IAR_LANGUAGE_PRAGMA
  46:alignment.h   **** /* IAR recommend this technique for accessing unaligned data in
  47:alignment.h   ****  * https://www.iar.com/knowledge/support/technical-notes/compiler/accessing-unaligned-data
  48:alignment.h   ****  * This results in a single load / store instruction (if unaligned access is supported).
  49:alignment.h   ****  * According to that document, this is only supported on certain architectures.
  50:alignment.h   ****  */
  51:alignment.h   ****     #define UINT_UNALIGNED
  52:alignment.h   **** typedef uint16_t __packed mbedtls_uint16_unaligned_t;
  53:alignment.h   **** typedef uint32_t __packed mbedtls_uint32_unaligned_t;
  54:alignment.h   **** typedef uint64_t __packed mbedtls_uint64_unaligned_t;
  55:alignment.h   **** #elif defined(MBEDTLS_COMPILER_IS_GCC) && (MBEDTLS_GCC_VERSION >= 40504) && \
  56:alignment.h   ****     ((MBEDTLS_GCC_VERSION < 60300) || (!defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)))
  57:alignment.h   **** /*
  58:alignment.h   ****  * gcc may generate a branch to memcpy for calls like `memcpy(dest, src, 4)` rather than
  59:alignment.h   ****  * generating some LDR or LDRB instructions (similar for stores).
  60:alignment.h   ****  *
  61:alignment.h   ****  * This is architecture dependent: x86-64 seems fine even with old gcc; 32-bit Arm
  62:alignment.h   ****  * is affected. To keep it simple, we enable for all architectures.
  63:alignment.h   ****  *
  64:alignment.h   ****  * For versions of gcc < 5.4.0 this issue always happens.
  65:alignment.h   ****  * For gcc < 6.3.0, this issue happens at -O0
  66:alignment.h   ****  * For all versions, this issue happens iff unaligned access is not supported.
  67:alignment.h   ****  *
  68:alignment.h   ****  * For gcc 4.x, this implementation will generate byte-by-byte loads even if unaligned access is
  69:alignment.h   ****  * supported, which is correct but not optimal.
  70:alignment.h   ****  *
  71:alignment.h   ****  * For performance (and code size, in some cases), we want to avoid the branch and just generate
  72:alignment.h   ****  * some inline load/store instructions since the access is small and constant-size.
  73:alignment.h   ****  *
  74:alignment.h   ****  * The manual states:
  75:alignment.h   ****  * "The packed attribute specifies that a variable or structure field should have the smallest
  76:alignment.h   ****  *  possible alignment—one byte for a variable"
  77:alignment.h   ****  * https://gcc.gnu.org/onlinedocs/gcc-4.5.4/gcc/Variable-Attributes.html
  78:alignment.h   ****  *
  79:alignment.h   ****  * Previous implementations used __attribute__((__aligned__(1)), but had issues with a gcc bug:
  80:alignment.h   ****  * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94662
  81:alignment.h   ****  *
  82:alignment.h   ****  * Tested with several versions of GCC from 4.5.0 up to 13.2.0
  83:alignment.h   ****  * We don't enable for older than 4.5.0 as this has not been tested.
  84:alignment.h   ****  */
  85:alignment.h   ****  #define UINT_UNALIGNED_STRUCT
  86:alignment.h   **** typedef struct {
  87:alignment.h   ****     uint16_t x;
  88:alignment.h   **** } __attribute__((packed)) mbedtls_uint16_unaligned_t;
  89:alignment.h   **** typedef struct {
  90:alignment.h   ****     uint32_t x;
  91:alignment.h   **** } __attribute__((packed)) mbedtls_uint32_unaligned_t;
  92:alignment.h   **** typedef struct {
  93:alignment.h   ****     uint64_t x;
  94:alignment.h   **** } __attribute__((packed)) mbedtls_uint64_unaligned_t;
  95:alignment.h   ****  #endif
  96:alignment.h   **** 
  97:alignment.h   **** /*
  98:alignment.h   ****  * We try to force mbedtls_(get|put)_unaligned_uintXX to be always inline, because this results
  99:alignment.h   ****  * in code that is both smaller and faster. IAR and gcc both benefit from this when optimising
 100:alignment.h   ****  * for size.
 101:alignment.h   ****  */
 102:alignment.h   **** 
 103:alignment.h   **** /**
 104:alignment.h   ****  * Read the unsigned 16 bits integer from the given address, which need not
 105:alignment.h   ****  * be aligned.
 106:alignment.h   ****  *
 107:alignment.h   ****  * \param   p pointer to 2 bytes of data
 108:alignment.h   ****  * \return  Data at the given address
 109:alignment.h   ****  */
 110:alignment.h   **** #if defined(__IAR_SYSTEMS_ICC__)
 111:alignment.h   **** #pragma inline = forced
 112:alignment.h   **** #elif defined(__GNUC__)
 113:alignment.h   **** __attribute__((always_inline))
 114:alignment.h   **** #endif
 115:alignment.h   **** static inline uint16_t mbedtls_get_unaligned_uint16(const void *p)
 116:alignment.h   **** {
 117:alignment.h   ****     uint16_t r;
 118:alignment.h   **** #if defined(UINT_UNALIGNED)
 119:alignment.h   ****     mbedtls_uint16_unaligned_t *p16 = (mbedtls_uint16_unaligned_t *) p;
 120:alignment.h   ****     r = *p16;
 121:alignment.h   **** #elif defined(UINT_UNALIGNED_STRUCT)
 122:alignment.h   ****     mbedtls_uint16_unaligned_t *p16 = (mbedtls_uint16_unaligned_t *) p;
 123:alignment.h   ****     r = p16->x;
 124:alignment.h   **** #else
 125:alignment.h   ****     memcpy(&r, p, sizeof(r));
 126:alignment.h   **** #endif
 127:alignment.h   ****     return r;
 128:alignment.h   **** }
 129:alignment.h   **** 
 130:alignment.h   **** /**
 131:alignment.h   ****  * Write the unsigned 16 bits integer to the given address, which need not
 132:alignment.h   ****  * be aligned.
 133:alignment.h   ****  *
 134:alignment.h   ****  * \param   p pointer to 2 bytes of data
 135:alignment.h   ****  * \param   x data to write
 136:alignment.h   ****  */
 137:alignment.h   **** #if defined(__IAR_SYSTEMS_ICC__)
 138:alignment.h   **** #pragma inline = forced
 139:alignment.h   **** #elif defined(__GNUC__)
 140:alignment.h   **** __attribute__((always_inline))
 141:alignment.h   **** #endif
 142:alignment.h   **** static inline void mbedtls_put_unaligned_uint16(void *p, uint16_t x)
 143:alignment.h   **** {
 144:alignment.h   **** #if defined(UINT_UNALIGNED)
 145:alignment.h   ****     mbedtls_uint16_unaligned_t *p16 = (mbedtls_uint16_unaligned_t *) p;
 146:alignment.h   ****     *p16 = x;
 147:alignment.h   **** #elif defined(UINT_UNALIGNED_STRUCT)
 148:alignment.h   ****     mbedtls_uint16_unaligned_t *p16 = (mbedtls_uint16_unaligned_t *) p;
 149:alignment.h   ****     p16->x = x;
 150:alignment.h   **** #else
 151:alignment.h   ****     memcpy(p, &x, sizeof(x));
 152:alignment.h   **** #endif
 153:alignment.h   **** }
 154:alignment.h   **** 
 155:alignment.h   **** /**
 156:alignment.h   ****  * Read the unsigned 32 bits integer from the given address, which need not
 157:alignment.h   ****  * be aligned.
 158:alignment.h   ****  *
 159:alignment.h   ****  * \param   p pointer to 4 bytes of data
 160:alignment.h   ****  * \return  Data at the given address
 161:alignment.h   ****  */
 162:alignment.h   **** #if defined(__IAR_SYSTEMS_ICC__)
 163:alignment.h   **** #pragma inline = forced
 164:alignment.h   **** #elif defined(__GNUC__)
 165:alignment.h   **** __attribute__((always_inline))
 166:alignment.h   **** #endif
 167:alignment.h   **** static inline uint32_t mbedtls_get_unaligned_uint32(const void *p)
 168:alignment.h   **** {
 169:alignment.h   ****     uint32_t r;
 576              		.loc 2 169 5 is_stmt 1 discriminator 3 view .LVU211
 170:alignment.h   **** #if defined(UINT_UNALIGNED)
 171:alignment.h   ****     mbedtls_uint32_unaligned_t *p32 = (mbedtls_uint32_unaligned_t *) p;
 172:alignment.h   ****     r = *p32;
 173:alignment.h   **** #elif defined(UINT_UNALIGNED_STRUCT)
 174:alignment.h   ****     mbedtls_uint32_unaligned_t *p32 = (mbedtls_uint32_unaligned_t *) p;
 175:alignment.h   ****     r = p32->x;
 176:alignment.h   **** #else
 177:alignment.h   ****     memcpy(&r, p, sizeof(r));
 577              		.loc 2 177 5 discriminator 3 view .LVU212
 578 00c2 51F8042B 		ldr	r2, [r1], #4	@ unaligned
 579              	.LVL54:
 178:alignment.h   **** #endif
 179:alignment.h   ****     return r;
 580              		.loc 2 179 5 discriminator 3 view .LVU213
 581              	.LBB111:
 197:simpleserial-glitch.c ****     }
 582              		.loc 1 197 15 is_stmt 0 discriminator 3 view .LVU214
 583 00c6 43F8042B 		str	r2, [r3], #4
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 584              		.loc 1 196 50 is_stmt 1 discriminator 3 view .LVU215
 585 00ca BBE7     		b	.L28
 586              	.LVL55:
 587              	.L30:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 588              		.loc 1 196 50 is_stmt 0 discriminator 3 view .LVU216
 589 00cc 4A49     		ldr	r1, .L42+4
 590 00ce 2846     		mov	r0, r5
 591 00d0 05F1C004 		add	r4, r5, #192
 592 00d4 0A46     		mov	r2, r1
 593              	.LVL56:
 594              	.L33:
 196:simpleserial-glitch.c ****         RK[i] = MBEDTLS_GET_UINT32_LE(key, i << 2);
 595              		.loc 1 196 50 discriminator 3 view .LVU217
 596              	.LBE111:
 597              	.LBB112:
 220:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[5])]) ^
 598              		.loc 1 220 17 is_stmt 1 discriminator 3 view .LVU218
 221:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] <<  8) ^
 599              		.loc 1 221 42 is_stmt 0 discriminator 3 view .LVU219
 600 00d6 C569     		ldr	r5, [r0, #28]
 220:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[5])]) ^
 601              		.loc 1 220 49 discriminator 3 view .LVU220
 602 00d8 51F8046B 		ldr	r6, [r1], #4
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 603              		.loc 1 223 72 discriminator 3 view .LVU221
 604 00dc 8768     		ldr	r7, [r0, #8]
 221:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] <<  8) ^
 605              		.loc 1 221 42 discriminator 3 view .LVU222
 606 00de C5F30723 		ubfx	r3, r5, #8, #8
 221:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] <<  8) ^
 607              		.loc 1 221 41 discriminator 3 view .LVU223
 608 00e2 1344     		add	r3, r3, r2
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 609              		.loc 1 223 72 discriminator 3 view .LVU224
 610 00e4 7E40     		eors	r6, r6, r7
 221:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] <<  8) ^
 611              		.loc 1 221 27 discriminator 3 view .LVU225
 612 00e6 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 613              		.loc 1 223 72 discriminator 3 view .LVU226
 614 00ea 7340     		eors	r3, r3, r6
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 615              		.loc 1 223 41 discriminator 3 view .LVU227
 616 00ec 02EB1566 		add	r6, r2, r5, lsr #24
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 617              		.loc 1 219 13 discriminator 3 view .LVU228
 618 00f0 1830     		adds	r0, r0, #24
 619              	.LVL57:
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 620              		.loc 1 223 27 discriminator 3 view .LVU229
 621 00f2 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 622              		.loc 1 223 72 discriminator 3 view .LVU230
 623 00f6 83EA0643 		eor	r3, r3, r6, lsl #16
 224:simpleserial-glitch.c **** 
 624              		.loc 1 224 41 discriminator 3 view .LVU231
 625 00fa 52FA85F6 		uxtab	r6, r2, r5
 224:simpleserial-glitch.c **** 
 626              		.loc 1 224 27 discriminator 3 view .LVU232
 627 00fe 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 628              		.loc 1 223 72 discriminator 3 view .LVU233
 629 0102 83EA0663 		eor	r3, r3, r6, lsl #24
 222:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[5])] << 16) ^
 630              		.loc 1 222 42 discriminator 3 view .LVU234
 631 0106 C5F30746 		ubfx	r6, r5, #16, #8
 222:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[5])] << 16) ^
 632              		.loc 1 222 41 discriminator 3 view .LVU235
 633 010a 1644     		add	r6, r6, r2
 222:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[5])] << 16) ^
 634              		.loc 1 222 27 discriminator 3 view .LVU236
 635 010c 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 223:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] << 24);
 636              		.loc 1 223 72 discriminator 3 view .LVU237
 637 0110 83EA0623 		eor	r3, r3, r6, lsl #8
 226:simpleserial-glitch.c ****                 RK[8]  = RK[2] ^ RK[7];
 638              		.loc 1 226 32 discriminator 3 view .LVU238
 639 0114 50F80C6C 		ldr	r6, [r0, #-12]
 220:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[5])]) ^
 640              		.loc 1 220 24 discriminator 3 view .LVU239
 641 0118 8360     		str	r3, [r0, #8]
 226:simpleserial-glitch.c ****                 RK[8]  = RK[2] ^ RK[7];
 642              		.loc 1 226 17 is_stmt 1 discriminator 3 view .LVU240
 226:simpleserial-glitch.c ****                 RK[8]  = RK[2] ^ RK[7];
 643              		.loc 1 226 32 is_stmt 0 discriminator 3 view .LVU241
 644 011a 7340     		eors	r3, r3, r6
 227:simpleserial-glitch.c ****                 RK[9]  = RK[3] ^ RK[8];
 645              		.loc 1 227 32 discriminator 3 view .LVU242
 646 011c 50F8086C 		ldr	r6, [r0, #-8]
 226:simpleserial-glitch.c ****                 RK[8]  = RK[2] ^ RK[7];
 647              		.loc 1 226 24 discriminator 3 view .LVU243
 648 0120 C360     		str	r3, [r0, #12]
 227:simpleserial-glitch.c ****                 RK[9]  = RK[3] ^ RK[8];
 649              		.loc 1 227 17 is_stmt 1 discriminator 3 view .LVU244
 227:simpleserial-glitch.c ****                 RK[9]  = RK[3] ^ RK[8];
 650              		.loc 1 227 32 is_stmt 0 discriminator 3 view .LVU245
 651 0122 7340     		eors	r3, r3, r6
 228:simpleserial-glitch.c ****                 RK[10] = RK[4] ^ RK[9];
 652              		.loc 1 228 32 discriminator 3 view .LVU246
 653 0124 50F8046C 		ldr	r6, [r0, #-4]
 227:simpleserial-glitch.c ****                 RK[9]  = RK[3] ^ RK[8];
 654              		.loc 1 227 24 discriminator 3 view .LVU247
 655 0128 0361     		str	r3, [r0, #16]
 228:simpleserial-glitch.c ****                 RK[10] = RK[4] ^ RK[9];
 656              		.loc 1 228 17 is_stmt 1 discriminator 3 view .LVU248
 228:simpleserial-glitch.c ****                 RK[10] = RK[4] ^ RK[9];
 657              		.loc 1 228 32 is_stmt 0 discriminator 3 view .LVU249
 658 012a 7340     		eors	r3, r3, r6
 229:simpleserial-glitch.c ****                 RK[11] = RK[5] ^ RK[10];
 659              		.loc 1 229 32 discriminator 3 view .LVU250
 660 012c 0668     		ldr	r6, [r0]
 228:simpleserial-glitch.c ****                 RK[10] = RK[4] ^ RK[9];
 661              		.loc 1 228 24 discriminator 3 view .LVU251
 662 012e 4361     		str	r3, [r0, #20]
 229:simpleserial-glitch.c ****                 RK[11] = RK[5] ^ RK[10];
 663              		.loc 1 229 17 is_stmt 1 discriminator 3 view .LVU252
 229:simpleserial-glitch.c ****                 RK[11] = RK[5] ^ RK[10];
 664              		.loc 1 229 32 is_stmt 0 discriminator 3 view .LVU253
 665 0130 7340     		eors	r3, r3, r6
 229:simpleserial-glitch.c ****                 RK[11] = RK[5] ^ RK[10];
 666              		.loc 1 229 24 discriminator 3 view .LVU254
 667 0132 8361     		str	r3, [r0, #24]
 230:simpleserial-glitch.c ****             }
 668              		.loc 1 230 17 is_stmt 1 discriminator 3 view .LVU255
 230:simpleserial-glitch.c ****             }
 669              		.loc 1 230 32 is_stmt 0 discriminator 3 view .LVU256
 670 0134 6B40     		eors	r3, r3, r5
 230:simpleserial-glitch.c ****             }
 671              		.loc 1 230 24 discriminator 3 view .LVU257
 672 0136 C361     		str	r3, [r0, #28]
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 673              		.loc 1 219 45 is_stmt 1 discriminator 3 view .LVU258
 674              	.LVL58:
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 675              		.loc 1 219 38 discriminator 3 view .LVU259
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 676              		.loc 1 219 13 is_stmt 0 discriminator 3 view .LVU260
 677 0138 8442     		cmp	r4, r0
 678 013a CCD1     		bne	.L33
 679 013c BBE7     		b	.L37
 680              	.LVL59:
 681              	.L31:
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 682              		.loc 1 219 13 discriminator 3 view .LVU261
 683 013e 2846     		mov	r0, r5
 684 0140 2D4D     		ldr	r5, .L42+4
 685              	.LVL60:
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 686              		.loc 1 219 13 discriminator 3 view .LVU262
 687 0142 00F1E006 		add	r6, r0, #224
 688              	.LVL61:
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 689              		.loc 1 219 13 discriminator 3 view .LVU263
 690 0146 2946     		mov	r1, r5
 691              	.LVL62:
 692              	.L35:
 219:simpleserial-glitch.c ****                 RK[6]  = RK[0] ^ round_constants[i] ^
 693              		.loc 1 219 13 discriminator 3 view .LVU264
 694              	.LBE112:
 695              	.LBB113:
 237:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[7])]) ^
 696              		.loc 1 237 17 is_stmt 1 discriminator 3 view .LVU265
 238:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] <<  8) ^
 697              		.loc 1 238 42 is_stmt 0 discriminator 3 view .LVU266
 698 0148 446A     		ldr	r4, [r0, #36]
 237:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[7])]) ^
 699              		.loc 1 237 49 discriminator 3 view .LVU267
 700 014a 55F8042B 		ldr	r2, [r5], #4
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 701              		.loc 1 240 72 discriminator 3 view .LVU268
 702 014e 8768     		ldr	r7, [r0, #8]
 238:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] <<  8) ^
 703              		.loc 1 238 42 discriminator 3 view .LVU269
 704 0150 C4F30723 		ubfx	r3, r4, #8, #8
 238:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] <<  8) ^
 705              		.loc 1 238 41 discriminator 3 view .LVU270
 706 0154 0B44     		add	r3, r3, r1
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 707              		.loc 1 240 72 discriminator 3 view .LVU271
 708 0156 7A40     		eors	r2, r2, r7
 238:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] <<  8) ^
 709              		.loc 1 238 27 discriminator 3 view .LVU272
 710 0158 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 711              		.loc 1 250 73 discriminator 3 view .LVU273
 712 015c 8769     		ldr	r7, [r0, #24]
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 713              		.loc 1 240 72 discriminator 3 view .LVU274
 714 015e 5340     		eors	r3, r3, r2
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 715              		.loc 1 240 41 discriminator 3 view .LVU275
 716 0160 01EB1462 		add	r2, r1, r4, lsr #24
 236:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 717              		.loc 1 236 13 discriminator 3 view .LVU276
 718 0164 2030     		adds	r0, r0, #32
 719              	.LVL63:
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 720              		.loc 1 240 27 discriminator 3 view .LVU277
 721 0166 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 722              		.loc 1 240 72 discriminator 3 view .LVU278
 723 016a 83EA0243 		eor	r3, r3, r2, lsl #16
 241:simpleserial-glitch.c **** 
 724              		.loc 1 241 41 discriminator 3 view .LVU279
 725 016e 51FA84F2 		uxtab	r2, r1, r4
 241:simpleserial-glitch.c **** 
 726              		.loc 1 241 27 discriminator 3 view .LVU280
 727 0172 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 728              		.loc 1 240 72 discriminator 3 view .LVU281
 729 0176 83EA0263 		eor	r3, r3, r2, lsl #24
 239:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[7])] << 16) ^
 730              		.loc 1 239 42 discriminator 3 view .LVU282
 731 017a C4F30742 		ubfx	r2, r4, #16, #8
 239:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[7])] << 16) ^
 732              		.loc 1 239 41 discriminator 3 view .LVU283
 733 017e 0A44     		add	r2, r2, r1
 239:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[7])] << 16) ^
 734              		.loc 1 239 27 discriminator 3 view .LVU284
 735 0180 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 240:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] << 24);
 736              		.loc 1 240 72 discriminator 3 view .LVU285
 737 0184 83EA0223 		eor	r3, r3, r2, lsl #8
 243:simpleserial-glitch.c ****                 RK[10] = RK[2] ^ RK[9];
 738              		.loc 1 243 32 discriminator 3 view .LVU286
 739 0188 50F8142C 		ldr	r2, [r0, #-20]
 237:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[7])]) ^
 740              		.loc 1 237 24 discriminator 3 view .LVU287
 741 018c 8360     		str	r3, [r0, #8]
 243:simpleserial-glitch.c ****                 RK[10] = RK[2] ^ RK[9];
 742              		.loc 1 243 17 is_stmt 1 discriminator 3 view .LVU288
 243:simpleserial-glitch.c ****                 RK[10] = RK[2] ^ RK[9];
 743              		.loc 1 243 32 is_stmt 0 discriminator 3 view .LVU289
 744 018e 5340     		eors	r3, r3, r2
 244:simpleserial-glitch.c ****                 RK[11] = RK[3] ^ RK[10];
 745              		.loc 1 244 32 discriminator 3 view .LVU290
 746 0190 50F8102C 		ldr	r2, [r0, #-16]
 243:simpleserial-glitch.c ****                 RK[10] = RK[2] ^ RK[9];
 747              		.loc 1 243 24 discriminator 3 view .LVU291
 748 0194 C360     		str	r3, [r0, #12]
 244:simpleserial-glitch.c ****                 RK[11] = RK[3] ^ RK[10];
 749              		.loc 1 244 17 is_stmt 1 discriminator 3 view .LVU292
 244:simpleserial-glitch.c ****                 RK[11] = RK[3] ^ RK[10];
 750              		.loc 1 244 32 is_stmt 0 discriminator 3 view .LVU293
 751 0196 5340     		eors	r3, r3, r2
 245:simpleserial-glitch.c **** 
 752              		.loc 1 245 32 discriminator 3 view .LVU294
 753 0198 50F80C2C 		ldr	r2, [r0, #-12]
 244:simpleserial-glitch.c ****                 RK[11] = RK[3] ^ RK[10];
 754              		.loc 1 244 24 discriminator 3 view .LVU295
 755 019c 0361     		str	r3, [r0, #16]
 245:simpleserial-glitch.c **** 
 756              		.loc 1 245 17 is_stmt 1 discriminator 3 view .LVU296
 245:simpleserial-glitch.c **** 
 757              		.loc 1 245 32 is_stmt 0 discriminator 3 view .LVU297
 758 019e 5340     		eors	r3, r3, r2
 248:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[11])] <<  8) ^
 759              		.loc 1 248 41 discriminator 3 view .LVU298
 760 01a0 51FA83F2 		uxtab	r2, r1, r3
 245:simpleserial-glitch.c **** 
 761              		.loc 1 245 24 discriminator 3 view .LVU299
 762 01a4 4361     		str	r3, [r0, #20]
 247:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[11])]) ^
 763              		.loc 1 247 17 is_stmt 1 discriminator 3 view .LVU300
 248:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[11])] <<  8) ^
 764              		.loc 1 248 27 is_stmt 0 discriminator 3 view .LVU301
 765 01a6 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 766              		.loc 1 250 73 discriminator 3 view .LVU302
 767 01aa 7A40     		eors	r2, r2, r7
 251:simpleserial-glitch.c **** 
 768              		.loc 1 251 41 discriminator 3 view .LVU303
 769 01ac 01EB1367 		add	r7, r1, r3, lsr #24
 251:simpleserial-glitch.c **** 
 770              		.loc 1 251 27 discriminator 3 view .LVU304
 771 01b0 97F82870 		ldrb	r7, [r7, #40]	@ zero_extendqisi2
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 772              		.loc 1 250 73 discriminator 3 view .LVU305
 773 01b4 82EA0762 		eor	r2, r2, r7, lsl #24
 249:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[11])] << 16) ^
 774              		.loc 1 249 42 discriminator 3 view .LVU306
 775 01b8 C3F30727 		ubfx	r7, r3, #8, #8
 249:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[11])] << 16) ^
 776              		.loc 1 249 41 discriminator 3 view .LVU307
 777 01bc 0F44     		add	r7, r7, r1
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 778              		.loc 1 250 42 discriminator 3 view .LVU308
 779 01be C3F30743 		ubfx	r3, r3, #16, #8
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 780              		.loc 1 250 41 discriminator 3 view .LVU309
 781 01c2 0B44     		add	r3, r3, r1
 249:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[11])] << 16) ^
 782              		.loc 1 249 27 discriminator 3 view .LVU310
 783 01c4 97F82870 		ldrb	r7, [r7, #40]	@ zero_extendqisi2
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 784              		.loc 1 250 27 discriminator 3 view .LVU311
 785 01c8 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 250:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] << 24);
 786              		.loc 1 250 73 discriminator 3 view .LVU312
 787 01cc 82EA0722 		eor	r2, r2, r7, lsl #8
 788 01d0 82EA0343 		eor	r3, r2, r3, lsl #16
 253:simpleserial-glitch.c ****                 RK[14] = RK[6] ^ RK[13];
 789              		.loc 1 253 32 discriminator 3 view .LVU313
 790 01d4 50F8042C 		ldr	r2, [r0, #-4]
 247:simpleserial-glitch.c ****                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[11])]) ^
 791              		.loc 1 247 24 discriminator 3 view .LVU314
 792 01d8 8361     		str	r3, [r0, #24]
 253:simpleserial-glitch.c ****                 RK[14] = RK[6] ^ RK[13];
 793              		.loc 1 253 17 is_stmt 1 discriminator 3 view .LVU315
 253:simpleserial-glitch.c ****                 RK[14] = RK[6] ^ RK[13];
 794              		.loc 1 253 32 is_stmt 0 discriminator 3 view .LVU316
 795 01da 5340     		eors	r3, r3, r2
 254:simpleserial-glitch.c ****                 RK[15] = RK[7] ^ RK[14];
 796              		.loc 1 254 32 discriminator 3 view .LVU317
 797 01dc 0268     		ldr	r2, [r0]
 253:simpleserial-glitch.c ****                 RK[14] = RK[6] ^ RK[13];
 798              		.loc 1 253 24 discriminator 3 view .LVU318
 799 01de C361     		str	r3, [r0, #28]
 254:simpleserial-glitch.c ****                 RK[15] = RK[7] ^ RK[14];
 800              		.loc 1 254 17 is_stmt 1 discriminator 3 view .LVU319
 254:simpleserial-glitch.c ****                 RK[15] = RK[7] ^ RK[14];
 801              		.loc 1 254 32 is_stmt 0 discriminator 3 view .LVU320
 802 01e0 5340     		eors	r3, r3, r2
 254:simpleserial-glitch.c ****                 RK[15] = RK[7] ^ RK[14];
 803              		.loc 1 254 24 discriminator 3 view .LVU321
 804 01e2 0362     		str	r3, [r0, #32]
 255:simpleserial-glitch.c ****             }
 805              		.loc 1 255 17 is_stmt 1 discriminator 3 view .LVU322
 255:simpleserial-glitch.c ****             }
 806              		.loc 1 255 32 is_stmt 0 discriminator 3 view .LVU323
 807 01e4 6340     		eors	r3, r3, r4
 255:simpleserial-glitch.c ****             }
 808              		.loc 1 255 24 discriminator 3 view .LVU324
 809 01e6 4362     		str	r3, [r0, #36]
 236:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 810              		.loc 1 236 45 is_stmt 1 discriminator 3 view .LVU325
 811              	.LVL64:
 236:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 812              		.loc 1 236 38 discriminator 3 view .LVU326
 236:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 813              		.loc 1 236 13 is_stmt 0 discriminator 3 view .LVU327
 814 01e8 8642     		cmp	r6, r0
 815 01ea ADD1     		bne	.L35
 816 01ec 63E7     		b	.L37
 817              	.LVL65:
 818              	.L36:
 236:simpleserial-glitch.c ****                 RK[8]  = RK[0] ^ round_constants[i] ^
 819              		.loc 1 236 13 discriminator 3 view .LVU328
 820              	.LBE113:
 177:simpleserial-glitch.c ****         case 128: ctx->nr = 10; break;
 821              		.loc 1 177 5 view .LVU329
 822 01ee 6FF01F00 		mvn	r0, #31
 823              	.LVL66:
 824              	.L22:
 263:simpleserial-glitch.c **** 
 825              		.loc 1 263 1 view .LVU330
 826 01f2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 827              	.L43:
 828              		.align	2
 829              	.L42:
 830 01f4 F8100000 		.word	.LANCHOR2
 831 01f8 00000000 		.word	.LANCHOR0
 832              		.cfi_endproc
 833              	.LFE15:
 835              		.section	.text.mbedtls_aes_init,"ax",%progbits
 836              		.align	1
 837              		.global	mbedtls_aes_init
 838              		.syntax unified
 839              		.thumb
 840              		.thumb_func
 842              	mbedtls_aes_init:
 843              	.LVL67:
 844              	.LFB16:
 268:simpleserial-glitch.c ****     memset(ctx, 0, sizeof(mbedtls_aes_context));
 845              		.loc 1 268 1 is_stmt 1 view -0
 846              		.cfi_startproc
 847              		@ args = 0, pretend = 0, frame = 0
 848              		@ frame_needed = 0, uses_anonymous_args = 0
 849              		@ link register save eliminated.
 269:simpleserial-glitch.c **** }
 850              		.loc 1 269 5 view .LVU332
 851 0000 4FF48C72 		mov	r2, #280
 852 0004 0021     		movs	r1, #0
 853 0006 FFF7FEBF 		b	memset
 854              	.LVL68:
 269:simpleserial-glitch.c **** }
 855              		.loc 1 269 5 is_stmt 0 view .LVU333
 856              		.cfi_endproc
 857              	.LFE16:
 859              		.section	.text.mbedtls_aes_free,"ax",%progbits
 860              		.align	1
 861              		.global	mbedtls_aes_free
 862              		.syntax unified
 863              		.thumb
 864              		.thumb_func
 866              	mbedtls_aes_free:
 867              	.LVL69:
 868              	.LFB17:
 273:simpleserial-glitch.c ****     if (ctx == NULL) {
 869              		.loc 1 273 1 is_stmt 1 view -0
 870              		.cfi_startproc
 871              		@ args = 0, pretend = 0, frame = 0
 872              		@ frame_needed = 0, uses_anonymous_args = 0
 873              		@ link register save eliminated.
 274:simpleserial-glitch.c ****         return;
 874              		.loc 1 274 5 view .LVU335
 274:simpleserial-glitch.c ****         return;
 875              		.loc 1 274 8 is_stmt 0 view .LVU336
 876 0000 18B1     		cbz	r0, .L45
 278:simpleserial-glitch.c **** }
 877              		.loc 1 278 5 is_stmt 1 view .LVU337
 878              	.LVL70:
 879              	.LBB114:
 880              	.LBI114:
 281:simpleserial-glitch.c **** {
 881              		.loc 1 281 6 view .LVU338
 882              	.LBB115:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 883              		.loc 1 283 5 view .LVU339
 884 0002 4FF48C71 		mov	r1, #280
 885 0006 FFF7FEBF 		b	mbedtls_platform_zeroize.part.0
 886              	.LVL71:
 887              	.L45:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 888              		.loc 1 283 5 is_stmt 0 view .LVU340
 889              	.LBE115:
 890              	.LBE114:
 279:simpleserial-glitch.c **** 
 891              		.loc 1 279 1 view .LVU341
 892 000a 7047     		bx	lr
 893              		.cfi_endproc
 894              	.LFE17:
 896              		.section	.text.mbedtls_platform_zeroize,"ax",%progbits
 897              		.align	1
 898              		.global	mbedtls_platform_zeroize
 899              		.syntax unified
 900              		.thumb
 901              		.thumb_func
 903              	mbedtls_platform_zeroize:
 904              	.LVL72:
 905              	.LFB18:
 282:simpleserial-glitch.c ****     if (len > 0) {
 906              		.loc 1 282 1 is_stmt 1 view -0
 907              		.cfi_startproc
 908              		@ args = 0, pretend = 0, frame = 0
 909              		@ frame_needed = 0, uses_anonymous_args = 0
 910              		@ link register save eliminated.
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 911              		.loc 1 283 5 view .LVU343
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 912              		.loc 1 283 8 is_stmt 0 view .LVU344
 913 0000 09B1     		cbz	r1, .L47
 914 0002 FFF7FEBF 		b	mbedtls_platform_zeroize.part.0
 915              	.LVL73:
 916              	.L47:
 917              		.loc 1 305 1 view .LVU345
 918 0006 7047     		bx	lr
 919              		.cfi_endproc
 920              	.LFE18:
 922              		.section	.text.mbedtls_aes_setkey_dec,"ax",%progbits
 923              		.align	1
 924              		.global	mbedtls_aes_setkey_dec
 925              		.syntax unified
 926              		.thumb
 927              		.thumb_func
 929              	mbedtls_aes_setkey_dec:
 930              	.LVL74:
 931              	.LFB19:
 306:simpleserial-glitch.c **** 
 307:simpleserial-glitch.c **** /*
 308:simpleserial-glitch.c ****  * AES key schedule (decryption)
 309:simpleserial-glitch.c ****  */
 310:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_SETKEY_DEC_ALT) && !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)
 311:simpleserial-glitch.c **** int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key,
 312:simpleserial-glitch.c ****                            unsigned int keybits)
 313:simpleserial-glitch.c **** {
 932              		.loc 1 313 1 is_stmt 1 view -0
 933              		.cfi_startproc
 934              		@ args = 0, pretend = 0, frame = 280
 935              		@ frame_needed = 0, uses_anonymous_args = 0
 314:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 315:simpleserial-glitch.c ****     uint32_t *SK;
 936              		.loc 1 315 5 view .LVU347
 316:simpleserial-glitch.c **** #endif
 317:simpleserial-glitch.c ****     int ret;
 937              		.loc 1 317 5 view .LVU348
 318:simpleserial-glitch.c ****     mbedtls_aes_context cty;
 938              		.loc 1 318 5 view .LVU349
 319:simpleserial-glitch.c ****     uint32_t *RK;
 939              		.loc 1 319 5 view .LVU350
 320:simpleserial-glitch.c **** 
 321:simpleserial-glitch.c **** 
 322:simpleserial-glitch.c ****     mbedtls_aes_init(&cty);
 940              		.loc 1 322 5 view .LVU351
 313:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 941              		.loc 1 313 1 is_stmt 0 view .LVU352
 942 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 943              	.LCFI5:
 944              		.cfi_def_cfa_offset 28
 945              		.cfi_offset 4, -28
 946              		.cfi_offset 5, -24
 947              		.cfi_offset 6, -20
 948              		.cfi_offset 7, -16
 949              		.cfi_offset 8, -12
 950              		.cfi_offset 9, -8
 951              		.cfi_offset 14, -4
 952 0004 C7B0     		sub	sp, sp, #284
 953              	.LCFI6:
 954              		.cfi_def_cfa_offset 312
 313:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 955              		.loc 1 313 1 view .LVU353
 956 0006 0446     		mov	r4, r0
 957              		.loc 1 322 5 view .LVU354
 958 0008 6846     		mov	r0, sp
 959              	.LVL75:
 313:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 960              		.loc 1 313 1 view .LVU355
 961 000a 0D46     		mov	r5, r1
 962 000c 1646     		mov	r6, r2
 963              		.loc 1 322 5 view .LVU356
 964 000e FFF7FEFF 		bl	mbedtls_aes_init
 965              	.LVL76:
 323:simpleserial-glitch.c **** 
 324:simpleserial-glitch.c ****     ctx->rk_offset = mbedtls_aes_rk_offset(ctx->buf);
 966              		.loc 1 324 5 is_stmt 1 view .LVU357
 164:simpleserial-glitch.c ****     return 0;
 967              		.loc 1 164 5 view .LVU358
 165:simpleserial-glitch.c **** }
 968              		.loc 1 165 5 view .LVU359
 969              		.loc 1 324 20 is_stmt 0 view .LVU360
 970 0012 0023     		movs	r3, #0
 971 0014 6360     		str	r3, [r4, #4]
 325:simpleserial-glitch.c ****     RK = ctx->buf + ctx->rk_offset;
 972              		.loc 1 325 5 is_stmt 1 view .LVU361
 973              	.LVL77:
 326:simpleserial-glitch.c **** 
 327:simpleserial-glitch.c ****     /* Also checks keybits */
 328:simpleserial-glitch.c ****     if ((ret = mbedtls_aes_setkey_enc(&cty, key, keybits)) != 0) {
 974              		.loc 1 328 5 view .LVU362
 975              		.loc 1 328 16 is_stmt 0 view .LVU363
 976 0016 3246     		mov	r2, r6
 977 0018 2946     		mov	r1, r5
 978 001a 6846     		mov	r0, sp
 979 001c FFF7FEFF 		bl	mbedtls_aes_setkey_enc
 980              	.LVL78:
 981              		.loc 1 328 8 view .LVU364
 982 0020 0746     		mov	r7, r0
 983 0022 0028     		cmp	r0, #0
 984 0024 37D1     		bne	.L50
 329:simpleserial-glitch.c ****         goto exit;
 330:simpleserial-glitch.c ****     }
 331:simpleserial-glitch.c **** 
 332:simpleserial-glitch.c ****     ctx->nr = cty.nr;
 985              		.loc 1 332 5 is_stmt 1 view .LVU365
 986              		.loc 1 332 18 is_stmt 0 view .LVU366
 987 0026 DDF80080 		ldr	r8, [sp]
 333:simpleserial-glitch.c **** 
 334:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 335:simpleserial-glitch.c ****     SK = cty.buf + cty.rk_offset + cty.nr * 4;
 988              		.loc 1 335 34 view .LVU367
 989 002a 019A     		ldr	r2, [sp, #4]
 332:simpleserial-glitch.c **** 
 990              		.loc 1 332 13 view .LVU368
 991 002c C4F80080 		str	r8, [r4]
 992              		.loc 1 335 5 is_stmt 1 view .LVU369
 993              		.loc 1 335 8 is_stmt 0 view .LVU370
 994 0030 02A9     		add	r1, sp, #8
 995              		.loc 1 335 34 view .LVU371
 996 0032 02EB8802 		add	r2, r2, r8, lsl #2
 997              		.loc 1 335 8 view .LVU372
 998 0036 01EB8203 		add	r3, r1, r2, lsl #2
 999              	.LVL79:
 336:simpleserial-glitch.c **** 
 337:simpleserial-glitch.c ****     *RK++ = *SK++;
 1000              		.loc 1 337 5 is_stmt 1 view .LVU373
 1001              		.loc 1 337 11 is_stmt 0 view .LVU374
 1002 003a 51F82220 		ldr	r2, [r1, r2, lsl #2]
 1003 003e A260     		str	r2, [r4, #8]
 338:simpleserial-glitch.c ****     *RK++ = *SK++;
 1004              		.loc 1 338 5 is_stmt 1 view .LVU375
 1005              	.LVL80:
 1006              		.loc 1 338 11 is_stmt 0 view .LVU376
 1007 0040 5A68     		ldr	r2, [r3, #4]
 1008 0042 E260     		str	r2, [r4, #12]
 339:simpleserial-glitch.c ****     *RK++ = *SK++;
 1009              		.loc 1 339 5 is_stmt 1 view .LVU377
 1010              	.LVL81:
 1011              		.loc 1 339 11 is_stmt 0 view .LVU378
 1012 0044 9A68     		ldr	r2, [r3, #8]
 1013 0046 2261     		str	r2, [r4, #16]
 340:simpleserial-glitch.c ****     *RK++ = *SK++;
 1014              		.loc 1 340 5 is_stmt 1 view .LVU379
 1015              	.LVL82:
 1016              		.loc 1 340 11 is_stmt 0 view .LVU380
 1017 0048 DA68     		ldr	r2, [r3, #12]
 1018 004a 6261     		str	r2, [r4, #20]
 1019              		.loc 1 340 8 view .LVU381
 1020 004c 04F11809 		add	r9, r4, #24
 1021              	.LVL83:
 341:simpleserial-glitch.c ****     SK -= 8;
 1022              		.loc 1 341 5 is_stmt 1 view .LVU382
 1023              	.LBB116:
 1024              	.LBB117:
 342:simpleserial-glitch.c ****     for (int i = ctx->nr - 1; i > 0; i--, SK -= 8) {
 343:simpleserial-glitch.c ****         for (int j = 0; j < 4; j++, SK++) {
 344:simpleserial-glitch.c ****             *RK++ = AES_RT0(FSb[MBEDTLS_BYTE_0(*SK)]) ^
 1025              		.loc 1 344 19 is_stmt 0 view .LVU383
 1026 0050 B8F1000F 		cmp	r8, #0
 1027              	.LBE117:
 342:simpleserial-glitch.c ****     for (int i = ctx->nr - 1; i > 0; i--, SK -= 8) {
 1028              		.loc 1 342 14 view .LVU384
 1029 0054 08F1FF34 		add	r4, r8, #-1
 1030              	.LVL84:
 1031              	.LBB118:
 1032              		.loc 1 344 19 view .LVU385
 1033 0058 4FEA0415 		lsl	r5, r4, #4
 1034              	.LVL85:
 1035              		.loc 1 344 19 view .LVU386
 1036 005c D8BF     		it	le
 1037 005e 0025     		movle	r5, #0
 1038 0060 0146     		mov	r1, r0
 1039 0062 2A46     		mov	r2, r5
 1040 0064 4846     		mov	r0, r9
 1041              	.LVL86:
 1042              		.loc 1 344 19 view .LVU387
 1043              	.LBE118:
 1044              	.LBE116:
 341:simpleserial-glitch.c ****     SK -= 8;
 1045              		.loc 1 341 8 view .LVU388
 1046 0066 A3F11006 		sub	r6, r3, #16
 1047              	.LVL87:
 342:simpleserial-glitch.c ****     for (int i = ctx->nr - 1; i > 0; i--, SK -= 8) {
 1048              		.loc 1 342 5 is_stmt 1 view .LVU389
 1049              	.LBB120:
 342:simpleserial-glitch.c ****     for (int i = ctx->nr - 1; i > 0; i--, SK -= 8) {
 1050              		.loc 1 342 10 view .LVU390
 1051              	.LBB119:
 1052              		.loc 1 344 19 is_stmt 0 view .LVU391
 1053 006a FFF7FEFF 		bl	memset
 1054              	.LVL88:
 1055              		.loc 1 344 19 view .LVU392
 1056 006e 6FF00F03 		mvn	r3, #15
 1057 0072 B8F1000F 		cmp	r8, #0
 1058 0076 04FB03F3 		mul	r3, r4, r3
 1059 007a D8BF     		it	le
 1060 007c 0023     		movle	r3, #0
 1061 007e F118     		adds	r1, r6, r3
 1062 0080 09EB0502 		add	r2, r9, r5
 1063              	.LBE119:
 1064              	.LBE120:
 345:simpleserial-glitch.c ****                     AES_RT1(FSb[MBEDTLS_BYTE_1(*SK)]) ^
 346:simpleserial-glitch.c ****                     AES_RT2(FSb[MBEDTLS_BYTE_2(*SK)]) ^
 347:simpleserial-glitch.c ****                     AES_RT3(FSb[MBEDTLS_BYTE_3(*SK)]);
 348:simpleserial-glitch.c ****         }
 349:simpleserial-glitch.c ****     }
 350:simpleserial-glitch.c **** 
 351:simpleserial-glitch.c ****     *RK++ = *SK++;
 1065              		.loc 1 351 5 is_stmt 1 view .LVU393
 1066              	.LVL89:
 1067              		.loc 1 351 11 is_stmt 0 view .LVU394
 1068 0084 F358     		ldr	r3, [r6, r3]
 1069 0086 49F80530 		str	r3, [r9, r5]
 352:simpleserial-glitch.c ****     *RK++ = *SK++;
 1070              		.loc 1 352 5 is_stmt 1 view .LVU395
 1071              	.LVL90:
 1072              		.loc 1 352 11 is_stmt 0 view .LVU396
 1073 008a 4B68     		ldr	r3, [r1, #4]
 1074 008c 5360     		str	r3, [r2, #4]
 353:simpleserial-glitch.c ****     *RK++ = *SK++;
 1075              		.loc 1 353 5 is_stmt 1 view .LVU397
 1076              	.LVL91:
 1077              		.loc 1 353 11 is_stmt 0 view .LVU398
 1078 008e 8B68     		ldr	r3, [r1, #8]
 1079 0090 9360     		str	r3, [r2, #8]
 354:simpleserial-glitch.c ****     *RK++ = *SK++;
 1080              		.loc 1 354 5 is_stmt 1 view .LVU399
 1081              	.LVL92:
 1082              		.loc 1 354 11 is_stmt 0 view .LVU400
 1083 0092 CB68     		ldr	r3, [r1, #12]
 1084 0094 D360     		str	r3, [r2, #12]
 1085              	.LVL93:
 1086              	.L50:
 355:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */
 356:simpleserial-glitch.c **** exit:
 357:simpleserial-glitch.c ****     mbedtls_aes_free(&cty);
 1087              		.loc 1 357 5 is_stmt 1 view .LVU401
 1088 0096 6846     		mov	r0, sp
 1089 0098 FFF7FEFF 		bl	mbedtls_aes_free
 1090              	.LVL94:
 358:simpleserial-glitch.c **** 
 359:simpleserial-glitch.c ****     return ret;
 1091              		.loc 1 359 5 view .LVU402
 360:simpleserial-glitch.c **** }
 1092              		.loc 1 360 1 is_stmt 0 view .LVU403
 1093 009c 3846     		mov	r0, r7
 1094 009e 47B0     		add	sp, sp, #284
 1095              	.LCFI7:
 1096              		.cfi_def_cfa_offset 28
 1097              		@ sp needed
 1098 00a0 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1099              		.loc 1 360 1 view .LVU404
 1100              		.cfi_endproc
 1101              	.LFE19:
 1103              		.section	.text.mbedtls_internal_aes_encrypt,"ax",%progbits
 1104              		.align	1
 1105              		.global	mbedtls_internal_aes_encrypt
 1106              		.syntax unified
 1107              		.thumb
 1108              		.thumb_func
 1110              	mbedtls_internal_aes_encrypt:
 1111              	.LVL95:
 1112              	.LFB20:
 361:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_SETKEY_DEC_ALT && !MBEDTLS_BLOCK_CIPHER_NO_DECRYPT */
 362:simpleserial-glitch.c **** 
 363:simpleserial-glitch.c **** #define AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)                 \
 364:simpleserial-glitch.c ****     do                                                      \
 365:simpleserial-glitch.c ****     {                                                       \
 366:simpleserial-glitch.c ****         (X0) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y0)) ^    \
 367:simpleserial-glitch.c ****                AES_FT1(MBEDTLS_BYTE_1(Y1)) ^    \
 368:simpleserial-glitch.c ****                AES_FT2(MBEDTLS_BYTE_2(Y2)) ^    \
 369:simpleserial-glitch.c ****                AES_FT3(MBEDTLS_BYTE_3(Y3));     \
 370:simpleserial-glitch.c ****                                                             \
 371:simpleserial-glitch.c ****         (X1) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y1)) ^    \
 372:simpleserial-glitch.c ****                AES_FT1(MBEDTLS_BYTE_1(Y2)) ^    \
 373:simpleserial-glitch.c ****                AES_FT2(MBEDTLS_BYTE_2(Y3)) ^    \
 374:simpleserial-glitch.c ****                AES_FT3(MBEDTLS_BYTE_3(Y0));     \
 375:simpleserial-glitch.c ****                                                             \
 376:simpleserial-glitch.c ****         (X2) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y2)) ^    \
 377:simpleserial-glitch.c ****                AES_FT1(MBEDTLS_BYTE_1(Y3)) ^    \
 378:simpleserial-glitch.c ****                AES_FT2(MBEDTLS_BYTE_2(Y0)) ^    \
 379:simpleserial-glitch.c ****                AES_FT3(MBEDTLS_BYTE_3(Y1));     \
 380:simpleserial-glitch.c ****                                                             \
 381:simpleserial-glitch.c ****         (X3) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y3)) ^    \
 382:simpleserial-glitch.c ****                AES_FT1(MBEDTLS_BYTE_1(Y0)) ^    \
 383:simpleserial-glitch.c ****                AES_FT2(MBEDTLS_BYTE_2(Y1)) ^    \
 384:simpleserial-glitch.c ****                AES_FT3(MBEDTLS_BYTE_3(Y2));     \
 385:simpleserial-glitch.c ****     } while (0)
 386:simpleserial-glitch.c **** 
 387:simpleserial-glitch.c **** #define AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)                 \
 388:simpleserial-glitch.c ****     do                                                      \
 389:simpleserial-glitch.c ****     {                                                       \
 390:simpleserial-glitch.c ****         (X0) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y0)) ^    \
 391:simpleserial-glitch.c ****                AES_RT1(MBEDTLS_BYTE_1(Y3)) ^    \
 392:simpleserial-glitch.c ****                AES_RT2(MBEDTLS_BYTE_2(Y2)) ^    \
 393:simpleserial-glitch.c ****                AES_RT3(MBEDTLS_BYTE_3(Y1));     \
 394:simpleserial-glitch.c ****                                                             \
 395:simpleserial-glitch.c ****         (X1) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y1)) ^    \
 396:simpleserial-glitch.c ****                AES_RT1(MBEDTLS_BYTE_1(Y0)) ^    \
 397:simpleserial-glitch.c ****                AES_RT2(MBEDTLS_BYTE_2(Y3)) ^    \
 398:simpleserial-glitch.c ****                AES_RT3(MBEDTLS_BYTE_3(Y2));     \
 399:simpleserial-glitch.c ****                                                             \
 400:simpleserial-glitch.c ****         (X2) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y2)) ^    \
 401:simpleserial-glitch.c ****                AES_RT1(MBEDTLS_BYTE_1(Y1)) ^    \
 402:simpleserial-glitch.c ****                AES_RT2(MBEDTLS_BYTE_2(Y0)) ^    \
 403:simpleserial-glitch.c ****                AES_RT3(MBEDTLS_BYTE_3(Y3));     \
 404:simpleserial-glitch.c ****                                                             \
 405:simpleserial-glitch.c ****         (X3) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y3)) ^    \
 406:simpleserial-glitch.c ****                AES_RT1(MBEDTLS_BYTE_1(Y2)) ^    \
 407:simpleserial-glitch.c ****                AES_RT2(MBEDTLS_BYTE_2(Y1)) ^    \
 408:simpleserial-glitch.c ****                AES_RT3(MBEDTLS_BYTE_3(Y0));     \
 409:simpleserial-glitch.c ****     } while (0)
 410:simpleserial-glitch.c **** 
 411:simpleserial-glitch.c **** /*
 412:simpleserial-glitch.c ****  * AES-ECB block encryption
 413:simpleserial-glitch.c ****  */
 414:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_ENCRYPT_ALT)
 415:simpleserial-glitch.c **** int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx,
 416:simpleserial-glitch.c ****                                  const unsigned char input[16],
 417:simpleserial-glitch.c ****                                  unsigned char output[16])
 418:simpleserial-glitch.c **** {
 1113              		.loc 1 418 1 is_stmt 1 view -0
 1114              		.cfi_startproc
 1115              		@ args = 0, pretend = 0, frame = 48
 1116              		@ frame_needed = 0, uses_anonymous_args = 0
 419:simpleserial-glitch.c ****     int i;
 1117              		.loc 1 419 5 view .LVU406
 420:simpleserial-glitch.c ****     uint32_t *RK = ctx->buf + ctx->rk_offset;
 1118              		.loc 1 420 5 view .LVU407
 418:simpleserial-glitch.c ****     int i;
 1119              		.loc 1 418 1 is_stmt 0 view .LVU408
 1120 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1121              	.LCFI8:
 1122              		.cfi_def_cfa_offset 36
 1123              		.cfi_offset 4, -36
 1124              		.cfi_offset 5, -32
 1125              		.cfi_offset 6, -28
 1126              		.cfi_offset 7, -24
 1127              		.cfi_offset 8, -20
 1128              		.cfi_offset 9, -16
 1129              		.cfi_offset 10, -12
 1130              		.cfi_offset 11, -8
 1131              		.cfi_offset 14, -4
 1132              		.loc 1 420 20 view .LVU409
 1133 0004 00F10803 		add	r3, r0, #8
 1134              		.loc 1 420 29 view .LVU410
 1135 0008 4468     		ldr	r4, [r0, #4]
 421:simpleserial-glitch.c ****     struct {
 422:simpleserial-glitch.c ****         uint32_t X[4];
 423:simpleserial-glitch.c ****         uint32_t Y[4];
 424:simpleserial-glitch.c ****     } t;
 425:simpleserial-glitch.c **** 
 426:simpleserial-glitch.c ****     t.X[0] = MBEDTLS_GET_UINT32_LE(input,  0); t.X[0] ^= *RK++;
 1136              		.loc 1 426 55 view .LVU411
 1137 000a 0E68     		ldr	r6, [r1]	@ unaligned
 427:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1138              		.loc 1 427 55 view .LVU412
 1139 000c 4D68     		ldr	r5, [r1, #4]	@ unaligned
 420:simpleserial-glitch.c ****     struct {
 1140              		.loc 1 420 15 view .LVU413
 1141 000e 03EB840E 		add	lr, r3, r4, lsl #2
 1142              	.LVL96:
 421:simpleserial-glitch.c ****     struct {
 1143              		.loc 1 421 5 is_stmt 1 view .LVU414
 426:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1144              		.loc 1 426 5 view .LVU415
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1145              		.loc 2 169 5 view .LVU416
 177:alignment.h   **** #endif
 1146              		.loc 2 177 5 view .LVU417
 1147              		.loc 2 179 5 view .LVU418
 426:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1148              		.loc 1 426 48 view .LVU419
 426:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1149              		.loc 1 426 55 is_stmt 0 view .LVU420
 1150 0012 53F82430 		ldr	r3, [r3, r4, lsl #2]
 428:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1151              		.loc 1 428 55 view .LVU421
 1152 0016 8C68     		ldr	r4, [r1, #8]	@ unaligned
 429:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1153              		.loc 1 429 55 view .LVU422
 1154 0018 C968     		ldr	r1, [r1, #12]	@ unaligned
 1155              	.LVL97:
 426:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1156              		.loc 1 426 55 view .LVU423
 1157 001a 5E40     		eors	r6, r6, r3
 427:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1158              		.loc 1 427 55 view .LVU424
 1159 001c DEF80430 		ldr	r3, [lr, #4]
 1160 0020 5D40     		eors	r5, r5, r3
 428:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1161              		.loc 1 428 55 view .LVU425
 1162 0022 DEF80830 		ldr	r3, [lr, #8]
 1163 0026 5C40     		eors	r4, r4, r3
 1164              		.loc 1 429 55 view .LVU426
 1165 0028 DEF80C30 		ldr	r3, [lr, #12]
 1166 002c 5940     		eors	r1, r1, r3
 430:simpleserial-glitch.c **** 
 431:simpleserial-glitch.c ****     for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
 1167              		.loc 1 431 23 view .LVU427
 1168 002e 0368     		ldr	r3, [r0]
 418:simpleserial-glitch.c ****     int i;
 1169              		.loc 1 418 1 view .LVU428
 1170 0030 8DB0     		sub	sp, sp, #52
 1171              	.LCFI9:
 1172              		.cfi_def_cfa_offset 88
 1173              		.loc 1 431 23 view .LVU429
 1174 0032 4FEA6308 		asr	r8, r3, #1
 1175 0036 8E4B     		ldr	r3, .L58
 426:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1176              		.loc 1 426 55 view .LVU430
 1177 0038 0496     		str	r6, [sp, #16]
 427:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1178              		.loc 1 427 5 is_stmt 1 view .LVU431
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1179              		.loc 2 169 5 view .LVU432
 177:alignment.h   **** #endif
 1180              		.loc 2 177 5 view .LVU433
 1181              		.loc 2 179 5 view .LVU434
 427:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1182              		.loc 1 427 48 view .LVU435
 1183              	.LVL98:
 427:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1184              		.loc 1 427 55 is_stmt 0 view .LVU436
 1185 003a 0595     		str	r5, [sp, #20]
 428:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1186              		.loc 1 428 5 is_stmt 1 view .LVU437
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1187              		.loc 2 169 5 view .LVU438
 177:alignment.h   **** #endif
 1188              		.loc 2 177 5 view .LVU439
 1189              		.loc 2 179 5 view .LVU440
 428:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1190              		.loc 1 428 48 view .LVU441
 1191              	.LVL99:
 428:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1192              		.loc 1 428 55 is_stmt 0 view .LVU442
 1193 003c 0694     		str	r4, [sp, #24]
 429:simpleserial-glitch.c **** 
 1194              		.loc 1 429 5 is_stmt 1 view .LVU443
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1195              		.loc 2 169 5 view .LVU444
 177:alignment.h   **** #endif
 1196              		.loc 2 177 5 view .LVU445
 1197              		.loc 2 179 5 view .LVU446
 429:simpleserial-glitch.c **** 
 1198              		.loc 1 429 48 view .LVU447
 1199              	.LVL100:
 429:simpleserial-glitch.c **** 
 1200              		.loc 1 429 55 is_stmt 0 view .LVU448
 1201 003e 0791     		str	r1, [sp, #28]
 1202              		.loc 1 431 5 is_stmt 1 view .LVU449
 1203              		.loc 1 431 12 is_stmt 0 view .LVU450
 1204 0040 08F1FF38 		add	r8, r8, #-1
 1205              	.LVL101:
 1206              		.loc 1 431 12 view .LVU451
 1207 0044 0EF1300E 		add	lr, lr, #48
 1208              	.LVL102:
 1209              		.loc 1 431 5 view .LVU452
 1210 0048 0020     		movs	r0, #0
 1211              	.LVL103:
 1212              	.L52:
 1213              		.loc 1 431 34 is_stmt 1 discriminator 1 view .LVU453
 432:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1214              		.loc 1 432 9 is_stmt 0 discriminator 1 view .LVU454
 1215 004a 5EE906A7 		ldrd	r10, r7, [lr, #-24]
 1216 004e 0097     		str	r7, [sp]
 433:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1217              		.loc 1 433 9 discriminator 1 view .LVU455
 1218 0050 5EF8107C 		ldr	r7, [lr, #-16]
 1219 0054 0197     		str	r7, [sp, #4]
 1220 0056 5EF80C7C 		ldr	r7, [lr, #-12]
 1221 005a 0297     		str	r7, [sp, #8]
 432:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1222              		.loc 1 432 9 discriminator 1 view .LVU456
 1223 005c 5EE908CB 		ldrd	ip, fp, [lr, #-32]
 1224              		.loc 1 433 9 discriminator 1 view .LVU457
 1225 0060 5EF8087C 		ldr	r7, [lr, #-8]
 1226 0064 0397     		str	r7, [sp, #12]
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1227              		.loc 1 431 5 discriminator 1 view .LVU458
 1228 0066 B8F1000F 		cmp	r8, #0
 1229 006a 0EF1200E 		add	lr, lr, #32
 1230              	.LVL104:
 1231              		.loc 1 433 9 discriminator 1 view .LVU459
 1232 006e 5EF8249C 		ldr	r9, [lr, #-36]
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1233              		.loc 1 431 5 discriminator 1 view .LVU460
 1234 0072 00F3FF80 		bgt	.L53
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1235              		.loc 1 431 5 discriminator 1 view .LVU461
 1236 0076 18B1     		cbz	r0, .L54
 1237 0078 CDE90465 		strd	r6, r5, [sp, #16]
 1238 007c CDE90641 		strd	r4, r1, [sp, #24]
 1239              	.L54:
 434:simpleserial-glitch.c ****     }
 435:simpleserial-glitch.c **** 
 436:simpleserial-glitch.c ****     AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1240              		.loc 1 436 5 is_stmt 1 view .LVU462
 1241              		.loc 1 436 5 view .LVU463
 1242              	.LVL105:
 1243              		.loc 1 436 5 is_stmt 0 view .LVU464
 1244 0080 DDE90454 		ldrd	r5, r4, [sp, #16]
 1245 0084 DDE90667 		ldrd	r6, r7, [sp, #24]
 1246 0088 E9B2     		uxtb	r1, r5
 1247 008a 380E     		lsrs	r0, r7, #24
 1248 008c 03EB8101 		add	r1, r3, r1, lsl #2
 1249 0090 03EB8000 		add	r0, r3, r0, lsl #2
 1250 0094 D1F82811 		ldr	r1, [r1, #296]
 1251 0098 D0F8280D 		ldr	r0, [r0, #3368]
 1252 009c 4140     		eors	r1, r1, r0
 1253 009e C4F30720 		ubfx	r0, r4, #8, #8
 1254 00a2 03EB8000 		add	r0, r3, r0, lsl #2
 1255 00a6 4FEA146E 		lsr	lr, r4, #24
 1256              	.LVL106:
 1257              		.loc 1 436 5 view .LVU465
 1258 00aa D0F82805 		ldr	r0, [r0, #1320]
 1259 00ae 4140     		eors	r1, r1, r0
 1260 00b0 C6F30740 		ubfx	r0, r6, #16, #8
 1261 00b4 03EB8000 		add	r0, r3, r0, lsl #2
 1262 00b8 03EB8E0E 		add	lr, r3, lr, lsl #2
 1263 00bc D0F82809 		ldr	r0, [r0, #2344]
 1264 00c0 DEF828ED 		ldr	lr, [lr, #3368]
 1265 00c4 4140     		eors	r1, r1, r0
 1266 00c6 81EA0C01 		eor	r1, r1, ip
 1267 00ca E0B2     		uxtb	r0, r4
 1268 00cc 4FEA156C 		lsr	ip, r5, #24
 1269 00d0 03EB8000 		add	r0, r3, r0, lsl #2
 1270 00d4 03EB8C0C 		add	ip, r3, ip, lsl #2
 1271 00d8 D0F82801 		ldr	r0, [r0, #296]
 1272 00dc DCF828CD 		ldr	ip, [ip, #3368]
 1273 00e0 0891     		str	r1, [sp, #32]
 1274              		.loc 1 436 5 is_stmt 1 view .LVU466
 1275              		.loc 1 436 5 is_stmt 0 view .LVU467
 1276 00e2 80EA0C00 		eor	r0, r0, ip
 1277 00e6 C6F3072C 		ubfx	ip, r6, #8, #8
 1278 00ea 03EB8C0C 		add	ip, r3, ip, lsl #2
 1279 00ee C4F30744 		ubfx	r4, r4, #16, #8
 1280 00f2 DCF828C5 		ldr	ip, [ip, #1320]
 1281 00f6 80EA0C00 		eor	r0, r0, ip
 1282 00fa C7F3074C 		ubfx	ip, r7, #16, #8
 1283 00fe 03EB8C0C 		add	ip, r3, ip, lsl #2
 1284 0102 03EB8404 		add	r4, r3, r4, lsl #2
 1285 0106 DCF828C9 		ldr	ip, [ip, #2344]
 1286 010a D4F82849 		ldr	r4, [r4, #2344]
 1287 010e 80EA0C00 		eor	r0, r0, ip
 1288 0112 5FFA86FC 		uxtb	ip, r6
 1289 0116 03EB8C0C 		add	ip, r3, ip, lsl #2
 1290 011a 360E     		lsrs	r6, r6, #24
 1291 011c DCF828C1 		ldr	ip, [ip, #296]
 1292 0120 8CEA0E0C 		eor	ip, ip, lr
 1293 0124 C7F3072E 		ubfx	lr, r7, #8, #8
 1294 0128 03EB8E0E 		add	lr, r3, lr, lsl #2
 1295 012c FFB2     		uxtb	r7, r7
 1296 012e DEF828E5 		ldr	lr, [lr, #1320]
 1297 0132 8CEA0E0C 		eor	ip, ip, lr
 1298 0136 C5F3074E 		ubfx	lr, r5, #16, #8
 1299 013a 03EB8E0E 		add	lr, r3, lr, lsl #2
 1300 013e 03EB8707 		add	r7, r3, r7, lsl #2
 1301 0142 DEF828E9 		ldr	lr, [lr, #2344]
 1302 0146 C5F30725 		ubfx	r5, r5, #8, #8
 1303 014a 8CEA0E0C 		eor	ip, ip, lr
 1304 014e 03EB860E 		add	lr, r3, r6, lsl #2
 1305 0152 03EB8505 		add	r5, r3, r5, lsl #2
 1306 0156 D7F82861 		ldr	r6, [r7, #296]
 1307 015a DEF8287D 		ldr	r7, [lr, #3368]
 1308 015e D5F82855 		ldr	r5, [r5, #1320]
 1309 0162 7E40     		eors	r6, r6, r7
 1310 0164 6E40     		eors	r6, r6, r5
 1311 0166 009D     		ldr	r5, [sp]
 437:simpleserial-glitch.c **** 
 438:simpleserial-glitch.c ****     t.X[0] = *RK++ ^ \
 439:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[0])]) ^
 440:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[1])] <<  8) ^
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[2])] << 16) ^
 1312              		.loc 1 441 61 view .LVU468
 1313 0168 019F     		ldr	r7, [sp, #4]
 436:simpleserial-glitch.c **** 
 1314              		.loc 1 436 5 view .LVU469
 1315 016a 7440     		eors	r4, r4, r6
 1316 016c 6C40     		eors	r4, r4, r5
 442:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1317              		.loc 1 442 29 view .LVU470
 1318 016e 03EB1465 		add	r5, r3, r4, lsr #24
 436:simpleserial-glitch.c **** 
 1319              		.loc 1 436 5 view .LVU471
 1320 0172 80EA0B00 		eor	r0, r0, fp
 1321              		.loc 1 442 15 view .LVU472
 1322 0176 95F82860 		ldrb	r6, [r5, #40]	@ zero_extendqisi2
 436:simpleserial-glitch.c **** 
 1323              		.loc 1 436 5 view .LVU473
 1324 017a 0990     		str	r0, [sp, #36]
 436:simpleserial-glitch.c **** 
 1325              		.loc 1 436 5 is_stmt 1 view .LVU474
 439:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[1])] <<  8) ^
 1326              		.loc 1 439 29 is_stmt 0 view .LVU475
 1327 017c 53FA81F5 		uxtab	r5, r3, r1
 436:simpleserial-glitch.c **** 
 1328              		.loc 1 436 5 view .LVU476
 1329 0180 8CEA0A0C 		eor	ip, ip, r10
 439:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[1])] <<  8) ^
 1330              		.loc 1 439 15 view .LVU477
 1331 0184 95F82850 		ldrb	r5, [r5, #40]	@ zero_extendqisi2
 436:simpleserial-glitch.c **** 
 1332              		.loc 1 436 5 view .LVU478
 1333 0188 CDF828C0 		str	ip, [sp, #40]
 436:simpleserial-glitch.c **** 
 1334              		.loc 1 436 5 is_stmt 1 view .LVU479
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1335              		.loc 1 441 61 is_stmt 0 view .LVU480
 1336 018c 7D40     		eors	r5, r5, r7
 1337 018e 85EA0665 		eor	r5, r5, r6, lsl #24
 440:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[2])] << 16) ^
 1338              		.loc 1 440 30 view .LVU481
 1339 0192 C0F30726 		ubfx	r6, r0, #8, #8
 440:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[2])] << 16) ^
 1340              		.loc 1 440 29 view .LVU482
 1341 0196 1E44     		add	r6, r6, r3
 436:simpleserial-glitch.c **** 
 1342              		.loc 1 436 5 view .LVU483
 1343 0198 0B94     		str	r4, [sp, #44]
 436:simpleserial-glitch.c **** 
 1344              		.loc 1 436 5 is_stmt 1 view .LVU484
 438:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[0])]) ^
 1345              		.loc 1 438 5 view .LVU485
 440:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[2])] << 16) ^
 1346              		.loc 1 440 15 is_stmt 0 view .LVU486
 1347 019a 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1348              		.loc 1 441 61 view .LVU487
 1349 019e 85EA0625 		eor	r5, r5, r6, lsl #8
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1350              		.loc 1 441 30 view .LVU488
 1351 01a2 CCF30746 		ubfx	r6, ip, #16, #8
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1352              		.loc 1 441 29 view .LVU489
 1353 01a6 1E44     		add	r6, r6, r3
 443:simpleserial-glitch.c **** 
 444:simpleserial-glitch.c ****     t.X[1] = *RK++ ^ \
 445:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[1])]) ^
 446:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[2])] <<  8) ^
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[3])] << 16) ^
 448:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 449:simpleserial-glitch.c **** 
 450:simpleserial-glitch.c ****     t.X[2] = *RK++ ^ \
 451:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[2])]) ^
 452:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[3])] <<  8) ^
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[0])] << 16) ^
 454:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 455:simpleserial-glitch.c **** 
 456:simpleserial-glitch.c ****     t.X[3] = *RK++ ^ \
 457:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[3])]) ^
 458:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[0])] <<  8) ^
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[1])] << 16) ^
 1354              		.loc 1 459 30 view .LVU490
 1355 01a8 C0F3074B 		ubfx	fp, r0, #16, #8
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1356              		.loc 1 441 15 view .LVU491
 1357 01ac 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 441:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 1358              		.loc 1 441 61 view .LVU492
 1359 01b0 85EA0648 		eor	r8, r5, r6, lsl #16
 1360              	.LVL107:
 448:simpleserial-glitch.c **** 
 1361              		.loc 1 448 29 view .LVU493
 1362 01b4 03EB1166 		add	r6, r3, r1, lsr #24
 438:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[0])]) ^
 1363              		.loc 1 438 12 view .LVU494
 1364 01b8 CDF81080 		str	r8, [sp, #16]
 444:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[1])]) ^
 1365              		.loc 1 444 5 is_stmt 1 view .LVU495
 448:simpleserial-glitch.c **** 
 1366              		.loc 1 448 15 is_stmt 0 view .LVU496
 1367 01bc 96F82870 		ldrb	r7, [r6, #40]	@ zero_extendqisi2
 445:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[2])] <<  8) ^
 1368              		.loc 1 445 29 view .LVU497
 1369 01c0 53FA80F6 		uxtab	r6, r3, r0
 445:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[2])] <<  8) ^
 1370              		.loc 1 445 15 view .LVU498
 1371 01c4 96F82860 		ldrb	r6, [r6, #40]	@ zero_extendqisi2
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1372              		.loc 1 447 61 view .LVU499
 1373 01c8 029D     		ldr	r5, [sp, #8]
 1374 01ca 6E40     		eors	r6, r6, r5
 1375 01cc 86EA0766 		eor	r6, r6, r7, lsl #24
 446:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[3])] << 16) ^
 1376              		.loc 1 446 30 view .LVU500
 1377 01d0 CCF30727 		ubfx	r7, ip, #8, #8
 446:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[3])] << 16) ^
 1378              		.loc 1 446 29 view .LVU501
 1379 01d4 1F44     		add	r7, r7, r3
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1380              		.loc 1 453 61 view .LVU502
 1381 01d6 039D     		ldr	r5, [sp, #12]
 446:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[3])] << 16) ^
 1382              		.loc 1 446 15 view .LVU503
 1383 01d8 97F82870 		ldrb	r7, [r7, #40]	@ zero_extendqisi2
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1384              		.loc 1 447 61 view .LVU504
 1385 01dc 86EA0726 		eor	r6, r6, r7, lsl #8
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1386              		.loc 1 447 30 view .LVU505
 1387 01e0 C4F30747 		ubfx	r7, r4, #16, #8
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1388              		.loc 1 447 29 view .LVU506
 1389 01e4 1F44     		add	r7, r7, r3
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1390              		.loc 1 447 15 view .LVU507
 1391 01e6 97F82870 		ldrb	r7, [r7, #40]	@ zero_extendqisi2
 447:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 1392              		.loc 1 447 61 view .LVU508
 1393 01ea 86EA0746 		eor	r6, r6, r7, lsl #16
 454:simpleserial-glitch.c **** 
 1394              		.loc 1 454 29 view .LVU509
 1395 01ee 03EB1067 		add	r7, r3, r0, lsr #24
 1396              	.LBB121:
 1397              	.LBB122:
 1398 01f2 04A8     		add	r0, sp, #16
 1399              	.LBE122:
 1400              	.LBE121:
 454:simpleserial-glitch.c **** 
 1401              		.loc 1 454 15 view .LVU510
 1402 01f4 97F828E0 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
 444:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[1])]) ^
 1403              		.loc 1 444 12 view .LVU511
 1404 01f8 0596     		str	r6, [sp, #20]
 450:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[2])]) ^
 1405              		.loc 1 450 5 is_stmt 1 view .LVU512
 451:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[3])] <<  8) ^
 1406              		.loc 1 451 29 is_stmt 0 view .LVU513
 1407 01fa 53FA8CF7 		uxtab	r7, r3, ip
 460:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1408              		.loc 1 460 29 view .LVU514
 1409 01fe 03EB1C6C 		add	ip, r3, ip, lsr #24
 451:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[3])] <<  8) ^
 1410              		.loc 1 451 15 view .LVU515
 1411 0202 97F82870 		ldrb	r7, [r7, #40]	@ zero_extendqisi2
 1412              		.loc 1 460 15 view .LVU516
 1413 0206 9CF828C0 		ldrb	ip, [ip, #40]	@ zero_extendqisi2
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1414              		.loc 1 453 61 view .LVU517
 1415 020a 6F40     		eors	r7, r7, r5
 1416 020c 87EA0E67 		eor	r7, r7, lr, lsl #24
 452:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[0])] << 16) ^
 1417              		.loc 1 452 30 view .LVU518
 1418 0210 C4F3072E 		ubfx	lr, r4, #8, #8
 457:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[0])] <<  8) ^
 1419              		.loc 1 457 29 view .LVU519
 1420 0214 53FA84F4 		uxtab	r4, r3, r4
 452:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[0])] << 16) ^
 1421              		.loc 1 452 29 view .LVU520
 1422 0218 9E44     		add	lr, lr, r3
 457:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[0])] <<  8) ^
 1423              		.loc 1 457 15 view .LVU521
 1424 021a 94F82840 		ldrb	r4, [r4, #40]	@ zero_extendqisi2
 452:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[0])] << 16) ^
 1425              		.loc 1 452 15 view .LVU522
 1426 021e 9EF828E0 		ldrb	lr, [lr, #40]	@ zero_extendqisi2
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1427              		.loc 1 459 61 view .LVU523
 1428 0222 84EA0909 		eor	r9, r4, r9
 1429 0226 89EA0C69 		eor	r9, r9, ip, lsl #24
 458:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[1])] << 16) ^
 1430              		.loc 1 458 30 view .LVU524
 1431 022a C1F3072C 		ubfx	ip, r1, #8, #8
 458:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[1])] << 16) ^
 1432              		.loc 1 458 29 view .LVU525
 1433 022e 9C44     		add	ip, ip, r3
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1434              		.loc 1 453 61 view .LVU526
 1435 0230 87EA0E27 		eor	r7, r7, lr, lsl #8
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1436              		.loc 1 453 30 view .LVU527
 1437 0234 C1F3074E 		ubfx	lr, r1, #16, #8
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1438              		.loc 1 453 29 view .LVU528
 1439 0238 9E44     		add	lr, lr, r3
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1440              		.loc 1 459 29 view .LVU529
 1441 023a 5B44     		add	r3, r3, fp
 458:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[1])] << 16) ^
 1442              		.loc 1 458 15 view .LVU530
 1443 023c 9CF82810 		ldrb	r1, [ip, #40]	@ zero_extendqisi2
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1444              		.loc 1 453 15 view .LVU531
 1445 0240 9EF828E0 		ldrb	lr, [lr, #40]	@ zero_extendqisi2
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1446              		.loc 1 459 15 view .LVU532
 1447 0244 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 1448              	.LBB125:
 1449              	.LBB126:
 180:alignment.h   **** }
 181:alignment.h   **** 
 182:alignment.h   **** /**
 183:alignment.h   ****  * Write the unsigned 32 bits integer to the given address, which need not
 184:alignment.h   ****  * be aligned.
 185:alignment.h   ****  *
 186:alignment.h   ****  * \param   p pointer to 4 bytes of data
 187:alignment.h   ****  * \param   x data to write
 188:alignment.h   ****  */
 189:alignment.h   **** #if defined(__IAR_SYSTEMS_ICC__)
 190:alignment.h   **** #pragma inline = forced
 191:alignment.h   **** #elif defined(__GNUC__)
 192:alignment.h   **** __attribute__((always_inline))
 193:alignment.h   **** #endif
 194:alignment.h   **** static inline void mbedtls_put_unaligned_uint32(void *p, uint32_t x)
 195:alignment.h   **** {
 196:alignment.h   **** #if defined(UINT_UNALIGNED)
 197:alignment.h   ****     mbedtls_uint32_unaligned_t *p32 = (mbedtls_uint32_unaligned_t *) p;
 198:alignment.h   ****     *p32 = x;
 199:alignment.h   **** #elif defined(UINT_UNALIGNED_STRUCT)
 200:alignment.h   ****     mbedtls_uint32_unaligned_t *p32 = (mbedtls_uint32_unaligned_t *) p;
 201:alignment.h   ****     p32->x = x;
 202:alignment.h   **** #else
 203:alignment.h   ****     memcpy(p, &x, sizeof(x));
 1450              		.loc 2 203 5 view .LVU533
 1451 0248 C2F80080 		str	r8, [r2]	@ unaligned
 1452              	.LVL108:
 1453              		.loc 2 203 5 view .LVU534
 1454              	.LBE126:
 1455              	.LBE125:
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1456              		.loc 1 459 61 view .LVU535
 1457 024c 89EA0129 		eor	r9, r9, r1, lsl #8
 453:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 1458              		.loc 1 453 61 view .LVU536
 1459 0250 87EA0E47 		eor	r7, r7, lr, lsl #16
 459:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 1460              		.loc 1 459 61 view .LVU537
 1461 0254 89EA0343 		eor	r3, r9, r3, lsl #16
 1462              	.LBB128:
 1463              	.LBB129:
 1464              		.loc 2 203 5 view .LVU538
 1465 0258 5660     		str	r6, [r2, #4]	@ unaligned
 1466              	.LBE129:
 1467              	.LBE128:
 1468              	.LBB131:
 1469              	.LBB132:
 1470 025a 9760     		str	r7, [r2, #8]	@ unaligned
 1471              	.LBE132:
 1472              	.LBE131:
 1473              	.LBB134:
 1474              	.LBB135:
 1475 025c D360     		str	r3, [r2, #12]	@ unaligned
 1476              	.LBE135:
 1477              	.LBE134:
 1478              	.LBB137:
 1479              	.LBB123:
 1480 025e 2021     		movs	r1, #32
 1481              	.LBE123:
 1482              	.LBE137:
 450:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[2])]) ^
 1483              		.loc 1 450 12 view .LVU539
 1484 0260 0697     		str	r7, [sp, #24]
 456:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[3])]) ^
 1485              		.loc 1 456 5 is_stmt 1 view .LVU540
 456:simpleserial-glitch.c ****              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[3])]) ^
 1486              		.loc 1 456 12 is_stmt 0 view .LVU541
 1487 0262 0793     		str	r3, [sp, #28]
 461:simpleserial-glitch.c **** 
 462:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[0], output,  0);
 1488              		.loc 1 462 5 is_stmt 1 view .LVU542
 1489              		.loc 1 462 5 view .LVU543
 1490              	.LVL109:
 1491              	.LBB138:
 1492              	.LBI125:
 194:alignment.h   **** {
 1493              		.loc 2 194 20 view .LVU544
 1494              	.LBB127:
 1495              		.loc 2 203 5 view .LVU545
 1496              		.loc 2 203 5 is_stmt 0 view .LVU546
 1497              	.LBE127:
 1498              	.LBE138:
 1499              		.loc 1 462 46 is_stmt 1 view .LVU547
 463:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);
 1500              		.loc 1 463 5 view .LVU548
 1501              		.loc 1 463 5 view .LVU549
 1502              	.LBB139:
 1503              	.LBI128:
 194:alignment.h   **** {
 1504              		.loc 2 194 20 view .LVU550
 1505              	.LBB130:
 1506              		.loc 2 203 5 view .LVU551
 1507              		.loc 2 203 5 is_stmt 0 view .LVU552
 1508              	.LBE130:
 1509              	.LBE139:
 1510              		.loc 1 463 46 is_stmt 1 view .LVU553
 464:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);
 1511              		.loc 1 464 5 view .LVU554
 1512              		.loc 1 464 5 view .LVU555
 1513              	.LBB140:
 1514              	.LBI131:
 194:alignment.h   **** {
 1515              		.loc 2 194 20 view .LVU556
 1516              	.LBB133:
 1517              		.loc 2 203 5 view .LVU557
 1518              		.loc 2 203 5 is_stmt 0 view .LVU558
 1519              	.LBE133:
 1520              	.LBE140:
 1521              		.loc 1 464 46 is_stmt 1 view .LVU559
 465:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);
 1522              		.loc 1 465 5 view .LVU560
 1523              		.loc 1 465 5 view .LVU561
 1524              	.LBB141:
 1525              	.LBI134:
 194:alignment.h   **** {
 1526              		.loc 2 194 20 view .LVU562
 1527              	.LBB136:
 1528              		.loc 2 203 5 view .LVU563
 1529              		.loc 2 203 5 is_stmt 0 view .LVU564
 1530              	.LBE136:
 1531              	.LBE141:
 1532              		.loc 1 465 46 is_stmt 1 view .LVU565
 466:simpleserial-glitch.c **** 
 467:simpleserial-glitch.c ****     mbedtls_platform_zeroize(&t, sizeof(t));
 1533              		.loc 1 467 5 view .LVU566
 1534              	.LBB142:
 1535              	.LBI121:
 281:simpleserial-glitch.c **** {
 1536              		.loc 1 281 6 view .LVU567
 1537              	.LBB124:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 1538              		.loc 1 283 5 view .LVU568
 1539 0264 FFF7FEFF 		bl	mbedtls_platform_zeroize.part.0
 1540              	.LVL110:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 1541              		.loc 1 283 5 is_stmt 0 view .LVU569
 1542              	.LBE124:
 1543              	.LBE142:
 468:simpleserial-glitch.c **** 
 469:simpleserial-glitch.c ****     return 0;
 1544              		.loc 1 469 5 is_stmt 1 view .LVU570
 470:simpleserial-glitch.c **** }
 1545              		.loc 1 470 1 is_stmt 0 view .LVU571
 1546 0268 0020     		movs	r0, #0
 1547 026a 0DB0     		add	sp, sp, #52
 1548              	.LCFI10:
 1549              		.cfi_remember_state
 1550              		.cfi_def_cfa_offset 36
 1551              		@ sp needed
 1552 026c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1553              	.L59:
 1554              		.align	2
 1555              	.L58:
 1556 0270 00000000 		.word	.LANCHOR0
 1557              	.LVL111:
 1558              	.L53:
 1559              	.LCFI11:
 1560              		.cfi_restore_state
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1561              		.loc 1 432 9 is_stmt 1 discriminator 3 view .LVU572
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1562              		.loc 1 432 9 discriminator 3 view .LVU573
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1563              		.loc 1 432 9 is_stmt 0 discriminator 3 view .LVU574
 1564 0274 F7B2     		uxtb	r7, r6
 1565 0276 080E     		lsrs	r0, r1, #24
 1566 0278 03EB8707 		add	r7, r3, r7, lsl #2
 1567 027c 03EB8000 		add	r0, r3, r0, lsl #2
 1568 0280 D7F82871 		ldr	r7, [r7, #296]
 1569 0284 D0F8280D 		ldr	r0, [r0, #3368]
 1570 0288 7840     		eors	r0, r0, r7
 1571 028a 80EA0C0C 		eor	ip, r0, ip
 1572 028e C5F30720 		ubfx	r0, r5, #8, #8
 1573 0292 03EB8000 		add	r0, r3, r0, lsl #2
 1574 0296 370E     		lsrs	r7, r6, #24
 1575 0298 D0F82805 		ldr	r0, [r0, #1320]
 1576 029c 8CEA000C 		eor	ip, ip, r0
 1577 02a0 C4F30740 		ubfx	r0, r4, #16, #8
 1578 02a4 03EB8000 		add	r0, r3, r0, lsl #2
 1579 02a8 03EB8707 		add	r7, r3, r7, lsl #2
 1580 02ac D0F82809 		ldr	r0, [r0, #2344]
 1581 02b0 D7F8287D 		ldr	r7, [r7, #3368]
 1582 02b4 8CEA000C 		eor	ip, ip, r0
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1583              		.loc 1 432 9 is_stmt 1 discriminator 3 view .LVU575
 1584              	.LVL112:
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1585              		.loc 1 432 9 is_stmt 0 discriminator 3 view .LVU576
 1586 02b8 E8B2     		uxtb	r0, r5
 1587 02ba 03EB8000 		add	r0, r3, r0, lsl #2
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1588              		.loc 1 431 42 discriminator 3 view .LVU577
 1589 02be 08F1FF38 		add	r8, r8, #-1
 1590              	.LVL113:
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1591              		.loc 1 432 9 discriminator 3 view .LVU578
 1592 02c2 D0F82801 		ldr	r0, [r0, #296]
 1593 02c6 7840     		eors	r0, r0, r7
 1594 02c8 C4F30727 		ubfx	r7, r4, #8, #8
 1595 02cc 03EB8707 		add	r7, r3, r7, lsl #2
 1596 02d0 80EA0B00 		eor	r0, r0, fp
 1597 02d4 D7F82875 		ldr	r7, [r7, #1320]
 1598 02d8 7840     		eors	r0, r0, r7
 1599 02da C1F30747 		ubfx	r7, r1, #16, #8
 1600 02de 03EB8707 		add	r7, r3, r7, lsl #2
 1601 02e2 4FEA156B 		lsr	fp, r5, #24
 1602 02e6 D7F82879 		ldr	r7, [r7, #2344]
 1603 02ea 7840     		eors	r0, r0, r7
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1604              		.loc 1 432 9 is_stmt 1 discriminator 3 view .LVU579
 1605              	.LVL114:
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1606              		.loc 1 432 9 is_stmt 0 discriminator 3 view .LVU580
 1607 02ec E7B2     		uxtb	r7, r4
 1608 02ee 03EB8707 		add	r7, r3, r7, lsl #2
 1609 02f2 03EB8B0B 		add	fp, r3, fp, lsl #2
 1610 02f6 D7F82871 		ldr	r7, [r7, #296]
 1611 02fa DBF828BD 		ldr	fp, [fp, #3368]
 1612 02fe 87EA0B0B 		eor	fp, r7, fp
 1613 0302 C1F30727 		ubfx	r7, r1, #8, #8
 1614 0306 03EB8707 		add	r7, r3, r7, lsl #2
 1615 030a C9B2     		uxtb	r1, r1
 1616 030c 240E     		lsrs	r4, r4, #24
 1617 030e 03EB8101 		add	r1, r3, r1, lsl #2
 1618 0312 03EB8404 		add	r4, r3, r4, lsl #2
 1619 0316 D7F82875 		ldr	r7, [r7, #1320]
 1620 031a D4F8284D 		ldr	r4, [r4, #3368]
 1621 031e D1F82811 		ldr	r1, [r1, #296]
 1622 0322 8BEA0A0A 		eor	r10, fp, r10
 1623 0326 8AEA070A 		eor	r10, r10, r7
 1624 032a C6F30747 		ubfx	r7, r6, #16, #8
 1625 032e C6F30726 		ubfx	r6, r6, #8, #8
 1626 0332 6140     		eors	r1, r1, r4
 1627 0334 03EB8606 		add	r6, r3, r6, lsl #2
 1628 0338 009C     		ldr	r4, [sp]
 1629 033a C5F30745 		ubfx	r5, r5, #16, #8
 1630 033e 6140     		eors	r1, r1, r4
 1631 0340 03EB8505 		add	r5, r3, r5, lsl #2
 1632 0344 D6F82845 		ldr	r4, [r6, #1320]
 1633 0348 6140     		eors	r1, r1, r4
 1634 034a D5F82849 		ldr	r4, [r5, #2344]
 1635 034e 6140     		eors	r1, r1, r4
 433:simpleserial-glitch.c ****     }
 1636              		.loc 1 433 9 discriminator 3 view .LVU581
 1637 0350 5FFA8CF5 		uxtb	r5, ip
 1638 0354 0C0E     		lsrs	r4, r1, #24
 1639 0356 03EB8505 		add	r5, r3, r5, lsl #2
 1640 035a 03EB8404 		add	r4, r3, r4, lsl #2
 1641 035e D5F82861 		ldr	r6, [r5, #296]
 1642 0362 D4F8284D 		ldr	r4, [r4, #3368]
 1643 0366 6640     		eors	r6, r6, r4
 1644 0368 019C     		ldr	r4, [sp, #4]
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1645              		.loc 1 432 9 discriminator 3 view .LVU582
 1646 036a 03EB8707 		add	r7, r3, r7, lsl #2
 433:simpleserial-glitch.c ****     }
 1647              		.loc 1 433 9 discriminator 3 view .LVU583
 1648 036e 6640     		eors	r6, r6, r4
 1649 0370 C0F30724 		ubfx	r4, r0, #8, #8
 1650 0374 03EB8404 		add	r4, r3, r4, lsl #2
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1651              		.loc 1 432 9 discriminator 3 view .LVU584
 1652 0378 D7F82879 		ldr	r7, [r7, #2344]
 433:simpleserial-glitch.c ****     }
 1653              		.loc 1 433 9 discriminator 3 view .LVU585
 1654 037c D4F82845 		ldr	r4, [r4, #1320]
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1655              		.loc 1 432 9 discriminator 3 view .LVU586
 1656 0380 8AEA070A 		eor	r10, r10, r7
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1657              		.loc 1 432 9 is_stmt 1 discriminator 3 view .LVU587
 1658              	.LVL115:
 432:simpleserial-glitch.c ****         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1659              		.loc 1 432 9 discriminator 3 view .LVU588
 433:simpleserial-glitch.c ****     }
 1660              		.loc 1 433 9 discriminator 3 view .LVU589
 433:simpleserial-glitch.c ****     }
 1661              		.loc 1 433 9 discriminator 3 view .LVU590
 433:simpleserial-glitch.c ****     }
 1662              		.loc 1 433 9 is_stmt 0 discriminator 3 view .LVU591
 1663 0384 6640     		eors	r6, r6, r4
 1664 0386 CAF30744 		ubfx	r4, r10, #16, #8
 1665 038a 03EB8404 		add	r4, r3, r4, lsl #2
 1666 038e C5B2     		uxtb	r5, r0
 1667 0390 D4F82849 		ldr	r4, [r4, #2344]
 1668 0394 6640     		eors	r6, r6, r4
 433:simpleserial-glitch.c ****     }
 1669              		.loc 1 433 9 is_stmt 1 discriminator 3 view .LVU592
 1670              	.LVL116:
 433:simpleserial-glitch.c ****     }
 1671              		.loc 1 433 9 is_stmt 0 discriminator 3 view .LVU593
 1672 0396 4FEA1C64 		lsr	r4, ip, #24
 1673 039a 03EB8505 		add	r5, r3, r5, lsl #2
 1674 039e 03EB8404 		add	r4, r3, r4, lsl #2
 1675 03a2 D5F82851 		ldr	r5, [r5, #296]
 1676 03a6 D4F8284D 		ldr	r4, [r4, #3368]
 1677 03aa 6540     		eors	r5, r5, r4
 1678 03ac 029C     		ldr	r4, [sp, #8]
 1679 03ae 6540     		eors	r5, r5, r4
 1680 03b0 CAF30724 		ubfx	r4, r10, #8, #8
 1681 03b4 03EB8404 		add	r4, r3, r4, lsl #2
 1682 03b8 070E     		lsrs	r7, r0, #24
 1683 03ba D4F82845 		ldr	r4, [r4, #1320]
 1684 03be 6540     		eors	r5, r5, r4
 1685 03c0 C1F30744 		ubfx	r4, r1, #16, #8
 1686 03c4 03EB8404 		add	r4, r3, r4, lsl #2
 1687 03c8 03EB8707 		add	r7, r3, r7, lsl #2
 1688 03cc D4F82849 		ldr	r4, [r4, #2344]
 1689 03d0 D7F8287D 		ldr	r7, [r7, #3368]
 1690 03d4 6540     		eors	r5, r5, r4
 433:simpleserial-glitch.c ****     }
 1691              		.loc 1 433 9 is_stmt 1 discriminator 3 view .LVU594
 1692              	.LVL117:
 433:simpleserial-glitch.c ****     }
 1693              		.loc 1 433 9 is_stmt 0 discriminator 3 view .LVU595
 1694 03d6 5FFA8AF4 		uxtb	r4, r10
 1695 03da 03EB8404 		add	r4, r3, r4, lsl #2
 1696 03de 4FEA1A6A 		lsr	r10, r10, #24
 1697 03e2 D4F82841 		ldr	r4, [r4, #296]
 1698 03e6 7C40     		eors	r4, r4, r7
 1699 03e8 039F     		ldr	r7, [sp, #12]
 1700 03ea 7C40     		eors	r4, r4, r7
 1701 03ec C1F30727 		ubfx	r7, r1, #8, #8
 1702 03f0 03EB8707 		add	r7, r3, r7, lsl #2
 1703 03f4 C9B2     		uxtb	r1, r1
 1704 03f6 D7F82875 		ldr	r7, [r7, #1320]
 1705 03fa 7C40     		eors	r4, r4, r7
 1706 03fc CCF30747 		ubfx	r7, ip, #16, #8
 1707 0400 03EB8707 		add	r7, r3, r7, lsl #2
 1708 0404 03EB8101 		add	r1, r3, r1, lsl #2
 1709 0408 D7F82879 		ldr	r7, [r7, #2344]
 1710 040c D1F82811 		ldr	r1, [r1, #296]
 1711 0410 03EB8A0A 		add	r10, r3, r10, lsl #2
 1712 0414 CCF3072C 		ubfx	ip, ip, #8, #8
 1713 0418 7C40     		eors	r4, r4, r7
 433:simpleserial-glitch.c ****     }
 1714              		.loc 1 433 9 is_stmt 1 discriminator 3 view .LVU596
 1715              	.LVL118:
 433:simpleserial-glitch.c ****     }
 1716              		.loc 1 433 9 is_stmt 0 discriminator 3 view .LVU597
 1717 041a 03EB8C0C 		add	ip, r3, ip, lsl #2
 1718 041e DAF8287D 		ldr	r7, [r10, #3368]
 1719 0422 C0F30740 		ubfx	r0, r0, #16, #8
 1720 0426 03EB8000 		add	r0, r3, r0, lsl #2
 1721 042a 7940     		eors	r1, r1, r7
 1722 042c DCF82875 		ldr	r7, [ip, #1320]
 1723 0430 D0F82809 		ldr	r0, [r0, #2344]
 1724 0434 81EA0901 		eor	r1, r1, r9
 1725 0438 7940     		eors	r1, r1, r7
 1726 043a 4140     		eors	r1, r1, r0
 433:simpleserial-glitch.c ****     }
 1727              		.loc 1 433 9 is_stmt 1 discriminator 3 view .LVU598
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1728              		.loc 1 431 41 discriminator 3 view .LVU599
 1729              	.LVL119:
 431:simpleserial-glitch.c ****         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1730              		.loc 1 431 42 is_stmt 0 discriminator 3 view .LVU600
 1731 043c 0120     		movs	r0, #1
 1732 043e 04E6     		b	.L52
 1733              		.cfi_endproc
 1734              	.LFE20:
 1736              		.section	.rodata.str1.1,"aMS",%progbits,1
 1737              	.LC0:
 1738 0000 5B464149 		.ascii	"[FAILED] ECB encryption!\000"
 1738      4C45445D 
 1738      20454342 
 1738      20656E63 
 1738      72797074 
 1739              		.section	.text.fault_and_encrypt,"ax",%progbits
 1740              		.align	1
 1741              		.global	fault_and_encrypt
 1742              		.syntax unified
 1743              		.thumb
 1744              		.thumb_func
 1746              	fault_and_encrypt:
 1747              	.LVL120:
 1748              	.LFB24:
 471:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_ENCRYPT_ALT */
 472:simpleserial-glitch.c **** 
 473:simpleserial-glitch.c **** /*
 474:simpleserial-glitch.c ****  * AES-ECB block decryption
 475:simpleserial-glitch.c ****  */
 476:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_DECRYPT_ALT) && !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)
 477:simpleserial-glitch.c **** int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,
 478:simpleserial-glitch.c ****                                  const unsigned char input[16],
 479:simpleserial-glitch.c ****                                  unsigned char output[16])
 480:simpleserial-glitch.c **** {
 481:simpleserial-glitch.c ****     int i;
 482:simpleserial-glitch.c ****     uint32_t *RK = ctx->buf + ctx->rk_offset;
 483:simpleserial-glitch.c ****     struct {
 484:simpleserial-glitch.c ****         uint32_t X[4];
 485:simpleserial-glitch.c ****         uint32_t Y[4];
 486:simpleserial-glitch.c ****     } t;
 487:simpleserial-glitch.c **** 
 488:simpleserial-glitch.c ****     t.X[0] = MBEDTLS_GET_UINT32_LE(input,  0); t.X[0] ^= *RK++;
 489:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 490:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 491:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 492:simpleserial-glitch.c **** 
 493:simpleserial-glitch.c ****     for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
 494:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 495:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 496:simpleserial-glitch.c ****     }
 497:simpleserial-glitch.c **** 
 498:simpleserial-glitch.c ****     AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 499:simpleserial-glitch.c **** 
 500:simpleserial-glitch.c ****     t.X[0] = *RK++ ^ \
 501:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[0])]) ^
 502:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[3])] <<  8) ^
 503:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[2])] << 16) ^
 504:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[1])] << 24);
 505:simpleserial-glitch.c **** 
 506:simpleserial-glitch.c ****     t.X[1] = *RK++ ^ \
 507:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[1])]) ^
 508:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[0])] <<  8) ^
 509:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[3])] << 16) ^
 510:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[2])] << 24);
 511:simpleserial-glitch.c **** 
 512:simpleserial-glitch.c ****     t.X[2] = *RK++ ^ \
 513:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[2])]) ^
 514:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[1])] <<  8) ^
 515:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[0])] << 16) ^
 516:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[3])] << 24);
 517:simpleserial-glitch.c **** 
 518:simpleserial-glitch.c ****     t.X[3] = *RK++ ^ \
 519:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[3])]) ^
 520:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[2])] <<  8) ^
 521:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[1])] << 16) ^
 522:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[0])] << 24);
 523:simpleserial-glitch.c **** 
 524:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[0], output,  0);
 525:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);
 526:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);
 527:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);
 528:simpleserial-glitch.c **** 
 529:simpleserial-glitch.c ****     mbedtls_platform_zeroize(&t, sizeof(t));
 530:simpleserial-glitch.c **** 
 531:simpleserial-glitch.c ****     return 0;
 532:simpleserial-glitch.c **** }
 533:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_DECRYPT_ALT && !MBEDTLS_BLOCK_CIPHER_NO_DECRYPT */
 534:simpleserial-glitch.c **** 
 535:simpleserial-glitch.c **** /*
 536:simpleserial-glitch.c ****  * AES-ECB block encryption/decryption
 537:simpleserial-glitch.c ****  */
 538:simpleserial-glitch.c **** int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,
 539:simpleserial-glitch.c ****                           int mode,
 540:simpleserial-glitch.c ****                           const unsigned char input[16],
 541:simpleserial-glitch.c ****                           unsigned char output[16])
 542:simpleserial-glitch.c **** {
 543:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 544:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 545:simpleserial-glitch.c ****     }
 546:simpleserial-glitch.c ****    
 547:simpleserial-glitch.c **** #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)
 548:simpleserial-glitch.c **** #if !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)
 549:simpleserial-glitch.c ****     if (mode == MBEDTLS_AES_DECRYPT) {
 550:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 551:simpleserial-glitch.c ****     } else
 552:simpleserial-glitch.c **** #endif
 553:simpleserial-glitch.c ****     {
 554:simpleserial-glitch.c ****         return mbedtls_internal_aes_encrypt(ctx, input, output);
 555:simpleserial-glitch.c ****     }
 556:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */
 557:simpleserial-glitch.c **** }
 558:simpleserial-glitch.c **** 
 559:simpleserial-glitch.c **** #if defined(MBEDTLS_CIPHER_MODE_CBC)
 560:simpleserial-glitch.c **** 
 561:simpleserial-glitch.c **** /*
 562:simpleserial-glitch.c ****  * AES-CBC buffer encryption/decryption
 563:simpleserial-glitch.c ****  */
 564:simpleserial-glitch.c **** int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,
 565:simpleserial-glitch.c ****                           int mode,
 566:simpleserial-glitch.c ****                           size_t length,
 567:simpleserial-glitch.c ****                           unsigned char iv[16],
 568:simpleserial-glitch.c ****                           const unsigned char *input,
 569:simpleserial-glitch.c ****                           unsigned char *output)
 570:simpleserial-glitch.c **** {
 571:simpleserial-glitch.c ****     int ret;
 572:simpleserial-glitch.c ****     unsigned char temp[16];
 573:simpleserial-glitch.c **** 
 574:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 575:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 576:simpleserial-glitch.c ****     }
 577:simpleserial-glitch.c **** 
 578:simpleserial-glitch.c ****     /* Nothing to do if length is zero. */
 579:simpleserial-glitch.c ****     if (length == 0) {
 580:simpleserial-glitch.c ****         return 0;
 581:simpleserial-glitch.c ****     }
 582:simpleserial-glitch.c **** 
 583:simpleserial-glitch.c ****     if (length % 16) {
 584:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 585:simpleserial-glitch.c ****     }
 586:simpleserial-glitch.c **** 
 587:simpleserial-glitch.c ****     const unsigned char *ivp = iv;
 588:simpleserial-glitch.c **** 
 589:simpleserial-glitch.c ****     if (mode == MBEDTLS_AES_DECRYPT) {
 590:simpleserial-glitch.c ****         while (length > 0) {
 591:simpleserial-glitch.c ****             memcpy(temp, input, 16);
 592:simpleserial-glitch.c ****             ret = mbedtls_aes_crypt_ecb(ctx, mode, input, output);
 593:simpleserial-glitch.c ****             if (ret != 0) {
 594:simpleserial-glitch.c ****                 goto exit;
 595:simpleserial-glitch.c ****             }
 596:simpleserial-glitch.c ****             /* Avoid using the NEON implementation of mbedtls_xor. Because of the dependency on
 597:simpleserial-glitch.c ****              * the result for the next block in CBC, and the cost of transferring that data from
 598:simpleserial-glitch.c ****              * NEON registers, NEON is slower on aarch64. */
 599:simpleserial-glitch.c ****             mbedtls_xor_no_simd(output, output, iv, 16);
 600:simpleserial-glitch.c **** 
 601:simpleserial-glitch.c ****             memcpy(iv, temp, 16);
 602:simpleserial-glitch.c **** 
 603:simpleserial-glitch.c ****             input  += 16;
 604:simpleserial-glitch.c ****             output += 16;
 605:simpleserial-glitch.c ****             length -= 16;
 606:simpleserial-glitch.c ****         }
 607:simpleserial-glitch.c ****     } else {
 608:simpleserial-glitch.c ****         while (length > 0) {
 609:simpleserial-glitch.c ****             mbedtls_xor_no_simd(output, input, ivp, 16);
 610:simpleserial-glitch.c **** 
 611:simpleserial-glitch.c ****             ret = mbedtls_aes_crypt_ecb(ctx, mode, output, output);
 612:simpleserial-glitch.c ****             if (ret != 0) {
 613:simpleserial-glitch.c ****                 goto exit;
 614:simpleserial-glitch.c ****             }
 615:simpleserial-glitch.c ****             ivp = output;
 616:simpleserial-glitch.c **** 
 617:simpleserial-glitch.c ****             input  += 16;
 618:simpleserial-glitch.c ****             output += 16;
 619:simpleserial-glitch.c ****             length -= 16;
 620:simpleserial-glitch.c ****         }
 621:simpleserial-glitch.c ****         memcpy(iv, ivp, 16);
 622:simpleserial-glitch.c ****     }
 623:simpleserial-glitch.c ****     ret = 0;
 624:simpleserial-glitch.c **** 
 625:simpleserial-glitch.c **** exit:
 626:simpleserial-glitch.c ****     return ret;
 627:simpleserial-glitch.c **** }
 628:simpleserial-glitch.c **** #endif /* MBEDTLS_CIPHER_MODE_CBC */
 629:simpleserial-glitch.c **** 
 630:simpleserial-glitch.c **** 
 631:simpleserial-glitch.c **** /*
 632:simpleserial-glitch.c ****  * Inject fault and encrypt 
 633:simpleserial-glitch.c ****  */
 634:simpleserial-glitch.c **** unsigned char key[16] = {0x5b, 0x12, 0xa4, 0x7f, 0x2b, 0x55, 0x71, 0x19, 
 635:simpleserial-glitch.c ****     0x1e, 0xc0, 0x6d, 0x7c, 0x02, 0xfc, 0x60, 0x76};
 636:simpleserial-glitch.c **** mbedtls_aes_context ctx;
 637:simpleserial-glitch.c **** static int aes_ctx_done = 0;
 638:simpleserial-glitch.c **** 
 639:simpleserial-glitch.c **** uint8_t fault_and_encrypt(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t* indata){
 1749              		.loc 1 639 83 is_stmt 1 view -0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 16
 1752              		@ frame_needed = 0, uses_anonymous_args = 0
 640:simpleserial-glitch.c **** 
 641:simpleserial-glitch.c ****     if (aes_ctx_done == 0){
 1753              		.loc 1 641 5 view .LVU602
 639:simpleserial-glitch.c **** 
 1754              		.loc 1 639 83 is_stmt 0 view .LVU603
 1755 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1756              	.LCFI12:
 1757              		.cfi_def_cfa_offset 32
 1758              		.cfi_offset 4, -16
 1759              		.cfi_offset 5, -12
 1760              		.cfi_offset 6, -8
 1761              		.cfi_offset 14, -4
 1762              		.loc 1 641 22 view .LVU604
 1763 0002 184D     		ldr	r5, .L66
 639:simpleserial-glitch.c **** 
 1764              		.loc 1 639 83 view .LVU605
 1765 0004 1C46     		mov	r4, r3
 1766              		.loc 1 641 8 view .LVU606
 1767 0006 AB6B     		ldr	r3, [r5, #56]
 1768              	.LVL121:
 1769              		.loc 1 641 8 view .LVU607
 1770 0008 5BB9     		cbnz	r3, .L61
 642:simpleserial-glitch.c ****         mbedtls_aes_init(&ctx);
 1771              		.loc 1 642 9 is_stmt 1 view .LVU608
 1772 000a 05F13C00 		add	r0, r5, #60
 1773              	.LVL122:
 1774              		.loc 1 642 9 is_stmt 0 view .LVU609
 1775 000e FFF7FEFF 		bl	mbedtls_aes_init
 1776              	.LVL123:
 643:simpleserial-glitch.c ****         mbedtls_aes_setkey_enc(&ctx, key, 128);
 1777              		.loc 1 643 9 is_stmt 1 view .LVU610
 1778 0012 1549     		ldr	r1, .L66+4
 1779 0014 8022     		movs	r2, #128
 1780 0016 05F13C00 		add	r0, r5, #60
 1781 001a FFF7FEFF 		bl	mbedtls_aes_setkey_enc
 1782              	.LVL124:
 644:simpleserial-glitch.c ****         aes_ctx_done = 1;        
 1783              		.loc 1 644 9 view .LVU611
 1784              		.loc 1 644 22 is_stmt 0 view .LVU612
 1785 001e 0123     		movs	r3, #1
 1786 0020 AB63     		str	r3, [r5, #56]
 1787              	.L61:
 1788              	.LBB146:
 645:simpleserial-glitch.c ****     }
 646:simpleserial-glitch.c **** 
 647:simpleserial-glitch.c ****     int ret = 0, mode=MBEDTLS_AES_ENCRYPT;
 648:simpleserial-glitch.c ****     unsigned char buf[16];
 649:simpleserial-glitch.c **** 
 650:simpleserial-glitch.c ****     for (int i = 0; i < 16; i++){
 651:simpleserial-glitch.c ****         buf[i] = indata[i];
 1789              		.loc 1 651 16 discriminator 3 view .LVU613
 1790 0022 2346     		mov	r3, r4
 1791 0024 6C46     		mov	r4, sp
 1792              	.LVL125:
 1793              		.loc 1 651 16 discriminator 3 view .LVU614
 1794 0026 03F11002 		add	r2, r3, #16
 1795 002a 2646     		mov	r6, r4
 1796              	.LVL126:
 1797              	.L62:
 1798              		.loc 1 651 16 discriminator 3 view .LVU615
 1799 002c 1868     		ldr	r0, [r3]	@ unaligned
 1800 002e 5968     		ldr	r1, [r3, #4]	@ unaligned
 1801 0030 2546     		mov	r5, r4
 1802 0032 03C5     		stmia	r5!, {r0, r1}
 1803 0034 0833     		adds	r3, r3, #8
 1804 0036 9342     		cmp	r3, r2
 1805 0038 2C46     		mov	r4, r5
 1806 003a F7D1     		bne	.L62
 1807              	.LBE146:
 652:simpleserial-glitch.c ****     }
 653:simpleserial-glitch.c **** 
 654:simpleserial-glitch.c ****     ret = mbedtls_aes_crypt_ecb(&ctx, mode, buf, buf);
 1808              		.loc 1 654 5 is_stmt 1 discriminator 3 view .LVU616
 1809              	.LVL127:
 1810              	.LBB147:
 1811              	.LBI147:
 538:simpleserial-glitch.c ****                           int mode,
 1812              		.loc 1 538 5 discriminator 3 view .LVU617
 1813              	.LBB148:
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 1814              		.loc 1 543 5 discriminator 3 view .LVU618
 549:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 1815              		.loc 1 549 5 discriminator 3 view .LVU619
 554:simpleserial-glitch.c ****     }
 1816              		.loc 1 554 9 discriminator 3 view .LVU620
 554:simpleserial-glitch.c ****     }
 1817              		.loc 1 554 16 is_stmt 0 discriminator 3 view .LVU621
 1818 003c 0B48     		ldr	r0, .L66+8
 1819 003e 3246     		mov	r2, r6
 1820              	.LVL128:
 554:simpleserial-glitch.c ****     }
 1821              		.loc 1 554 16 discriminator 3 view .LVU622
 1822 0040 3146     		mov	r1, r6
 1823 0042 FFF7FEFF 		bl	mbedtls_internal_aes_encrypt
 1824              	.LVL129:
 554:simpleserial-glitch.c ****     }
 1825              		.loc 1 554 16 discriminator 3 view .LVU623
 1826              	.LBE148:
 1827              	.LBE147:
 655:simpleserial-glitch.c ****     if (ret != 0) {
 1828              		.loc 1 655 5 is_stmt 1 discriminator 3 view .LVU624
 1829              		.loc 1 655 8 is_stmt 0 discriminator 3 view .LVU625
 1830 0046 0446     		mov	r4, r0
 1831 0048 28B1     		cbz	r0, .L63
 656:simpleserial-glitch.c ****         printf("[FAILED] ECB encryption!\n");
 1832              		.loc 1 656 9 is_stmt 1 view .LVU626
 1833 004a 0948     		ldr	r0, .L66+12
 1834              	.LVL130:
 1835              		.loc 1 656 9 is_stmt 0 view .LVU627
 1836 004c FFF7FEFF 		bl	puts
 1837              	.LVL131:
 657:simpleserial-glitch.c ****         return ret;
 1838              		.loc 1 657 9 is_stmt 1 view .LVU628
 1839              		.loc 1 657 16 is_stmt 0 view .LVU629
 1840 0050 E0B2     		uxtb	r0, r4
 1841              	.L64:
 658:simpleserial-glitch.c ****     }
 659:simpleserial-glitch.c ****     simpleserial_put('r', 16, buf);
 660:simpleserial-glitch.c ****     return 0;
 661:simpleserial-glitch.c **** }
 1842              		.loc 1 661 1 view .LVU630
 1843 0052 04B0     		add	sp, sp, #16
 1844              	.LCFI13:
 1845              		.cfi_remember_state
 1846              		.cfi_def_cfa_offset 16
 1847              		@ sp needed
 1848 0054 70BD     		pop	{r4, r5, r6, pc}
 1849              	.LVL132:
 1850              	.L63:
 1851              	.LCFI14:
 1852              		.cfi_restore_state
 659:simpleserial-glitch.c ****     return 0;
 1853              		.loc 1 659 5 is_stmt 1 view .LVU631
 1854 0056 7220     		movs	r0, #114
 1855              	.LVL133:
 659:simpleserial-glitch.c ****     return 0;
 1856              		.loc 1 659 5 is_stmt 0 view .LVU632
 1857 0058 3246     		mov	r2, r6
 1858 005a 1021     		movs	r1, #16
 1859 005c FFF7FEFF 		bl	simpleserial_put
 1860              	.LVL134:
 660:simpleserial-glitch.c **** }
 1861              		.loc 1 660 5 is_stmt 1 view .LVU633
 660:simpleserial-glitch.c **** }
 1862              		.loc 1 660 12 is_stmt 0 view .LVU634
 1863 0060 2046     		mov	r0, r4
 1864 0062 F6E7     		b	.L64
 1865              	.L67:
 1866              		.align	2
 1867              	.L66:
 1868 0064 F8100000 		.word	.LANCHOR2
 1869 0068 04000000 		.word	.LANCHOR1+4
 1870 006c 34110000 		.word	.LANCHOR2+60
 1871 0070 00000000 		.word	.LC0
 1872              		.cfi_endproc
 1873              	.LFE24:
 1875              		.section	.text.mbedtls_internal_aes_decrypt,"ax",%progbits
 1876              		.align	1
 1877              		.global	mbedtls_internal_aes_decrypt
 1878              		.syntax unified
 1879              		.thumb
 1880              		.thumb_func
 1882              	mbedtls_internal_aes_decrypt:
 1883              	.LVL135:
 1884              	.LFB21:
 480:simpleserial-glitch.c ****     int i;
 1885              		.loc 1 480 1 is_stmt 1 view -0
 1886              		.cfi_startproc
 1887              		@ args = 0, pretend = 0, frame = 32
 1888              		@ frame_needed = 0, uses_anonymous_args = 0
 481:simpleserial-glitch.c ****     uint32_t *RK = ctx->buf + ctx->rk_offset;
 1889              		.loc 1 481 5 view .LVU636
 482:simpleserial-glitch.c ****     struct {
 1890              		.loc 1 482 5 view .LVU637
 480:simpleserial-glitch.c ****     int i;
 1891              		.loc 1 480 1 is_stmt 0 view .LVU638
 1892 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1893              	.LCFI15:
 1894              		.cfi_def_cfa_offset 32
 1895              		.cfi_offset 4, -32
 1896              		.cfi_offset 5, -28
 1897              		.cfi_offset 6, -24
 1898              		.cfi_offset 7, -20
 1899              		.cfi_offset 8, -16
 1900              		.cfi_offset 9, -12
 1901              		.cfi_offset 10, -8
 1902              		.cfi_offset 14, -4
 482:simpleserial-glitch.c ****     struct {
 1903              		.loc 1 482 29 view .LVU639
 1904 0004 4468     		ldr	r4, [r0, #4]
 482:simpleserial-glitch.c ****     struct {
 1905              		.loc 1 482 15 view .LVU640
 1906 0006 00EB8404 		add	r4, r0, r4, lsl #2
 1907              	.LVL136:
 483:simpleserial-glitch.c ****         uint32_t X[4];
 1908              		.loc 1 483 5 is_stmt 1 view .LVU641
 488:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1909              		.loc 1 488 5 view .LVU642
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1910              		.loc 2 169 5 view .LVU643
 177:alignment.h   **** #endif
 1911              		.loc 2 177 5 view .LVU644
 179:alignment.h   **** }
 1912              		.loc 2 179 5 view .LVU645
 488:simpleserial-glitch.c ****     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;
 1913              		.loc 1 488 48 view .LVU646
 489:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1914              		.loc 1 489 5 view .LVU647
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1915              		.loc 2 169 5 view .LVU648
 177:alignment.h   **** #endif
 1916              		.loc 2 177 5 view .LVU649
 179:alignment.h   **** }
 1917              		.loc 2 179 5 view .LVU650
 489:simpleserial-glitch.c ****     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;
 1918              		.loc 1 489 48 view .LVU651
 490:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1919              		.loc 1 490 5 view .LVU652
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1920              		.loc 2 169 5 view .LVU653
 177:alignment.h   **** #endif
 1921              		.loc 2 177 5 view .LVU654
 179:alignment.h   **** }
 1922              		.loc 2 179 5 view .LVU655
 490:simpleserial-glitch.c ****     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;
 1923              		.loc 1 490 48 view .LVU656
 491:simpleserial-glitch.c **** 
 1924              		.loc 1 491 5 view .LVU657
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 1925              		.loc 2 169 5 view .LVU658
 177:alignment.h   **** #endif
 1926              		.loc 2 177 5 view .LVU659
 179:alignment.h   **** }
 1927              		.loc 2 179 5 view .LVU660
 491:simpleserial-glitch.c **** 
 1928              		.loc 1 491 48 view .LVU661
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1929              		.loc 1 493 23 is_stmt 0 view .LVU662
 1930 000a 0068     		ldr	r0, [r0]
 1931              	.LVL137:
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1932              		.loc 1 493 23 view .LVU663
 1933 000c 4010     		asrs	r0, r0, #1
 491:simpleserial-glitch.c **** 
 1934              		.loc 1 491 61 view .LVU664
 1935 000e 1834     		adds	r4, r4, #24
 1936              	.LVL138:
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1937              		.loc 1 493 5 is_stmt 1 view .LVU665
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1938              		.loc 1 493 12 is_stmt 0 view .LVU666
 1939 0010 411E     		subs	r1, r0, #1
 1940              	.LVL139:
 480:simpleserial-glitch.c ****     int i;
 1941              		.loc 1 480 1 view .LVU667
 1942 0012 88B0     		sub	sp, sp, #32
 1943              	.LCFI16:
 1944              		.cfi_def_cfa_offset 64
 491:simpleserial-glitch.c **** 
 1945              		.loc 1 491 61 view .LVU668
 1946 0014 2346     		mov	r3, r4
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1947              		.loc 1 493 12 view .LVU669
 1948 0016 8A46     		mov	r10, r1
 1949              	.LVL140:
 1950              	.L69:
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1951              		.loc 1 493 34 is_stmt 1 discriminator 1 view .LVU670
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1952              		.loc 1 493 5 is_stmt 0 discriminator 1 view .LVU671
 1953 0018 BAF1000F 		cmp	r10, #0
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 1954              		.loc 1 494 9 discriminator 1 view .LVU672
 1955 001c D3E90198 		ldrd	r9, r8, [r3, #4]
 495:simpleserial-glitch.c ****     }
 1956              		.loc 1 495 9 discriminator 1 view .LVU673
 1957 0020 D3E903EC 		ldrd	lr, ip, [r3, #12]
 1958 0024 D3E90576 		ldrd	r7, r6, [r3, #20]
 1959 0028 DD69     		ldr	r5, [r3, #28]
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 1960              		.loc 1 493 5 discriminator 1 view .LVU674
 1961 002a 1ADC     		bgt	.L70
 498:simpleserial-glitch.c **** 
 1962              		.loc 1 498 5 is_stmt 1 view .LVU675
 498:simpleserial-glitch.c **** 
 1963              		.loc 1 498 5 view .LVU676
 1964              	.LVL141:
 498:simpleserial-glitch.c **** 
 1965              		.loc 1 498 5 is_stmt 0 view .LVU677
 1966 002c 0028     		cmp	r0, #0
 1967 002e 4FEA4113 		lsl	r3, r1, #5
 1968 0032 D8BF     		it	le
 1969 0034 0023     		movle	r3, #0
 1970              	.LBB149:
 1971              	.LBB150:
 1972 0036 6846     		mov	r0, sp
 1973              	.LVL142:
 498:simpleserial-glitch.c **** 
 1974              		.loc 1 498 5 view .LVU678
 1975              	.LBE150:
 1976              	.LBE149:
 1977 0038 E358     		ldr	r3, [r4, r3]
 1978              	.LBB153:
 1979              	.LBB154:
 1980              		.loc 2 203 5 view .LVU679
 1981 003a C2F800C0 		str	ip, [r2]	@ unaligned
 1982              		.loc 2 203 5 view .LVU680
 1983              	.LBE154:
 1984              	.LBE153:
 1985              	.LBB156:
 1986              	.LBB157:
 1987 003e 5760     		str	r7, [r2, #4]	@ unaligned
 1988              	.LBE157:
 1989              	.LBE156:
 1990              	.LBB159:
 1991              	.LBB160:
 1992 0040 9660     		str	r6, [r2, #8]	@ unaligned
 1993              	.LBE160:
 1994              	.LBE159:
 1995              	.LBB162:
 1996              	.LBB163:
 1997 0042 D560     		str	r5, [r2, #12]	@ unaligned
 1998              	.LBE163:
 1999              	.LBE162:
 2000              	.LBB165:
 2001              	.LBB151:
 2002 0044 2021     		movs	r1, #32
 2003              	.LVL143:
 2004              		.loc 2 203 5 view .LVU681
 2005              	.LBE151:
 2006              	.LBE165:
 498:simpleserial-glitch.c **** 
 2007              		.loc 1 498 5 view .LVU682
 2008 0046 CDE90439 		strd	r3, r9, [sp, #16]
 498:simpleserial-glitch.c **** 
 2009              		.loc 1 498 5 is_stmt 1 view .LVU683
 498:simpleserial-glitch.c **** 
 2010              		.loc 1 498 5 is_stmt 0 view .LVU684
 2011 004a CDE9068E 		strd	r8, lr, [sp, #24]
 498:simpleserial-glitch.c **** 
 2012              		.loc 1 498 5 is_stmt 1 view .LVU685
 500:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[0])]) ^
 2013              		.loc 1 500 5 view .LVU686
 506:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[1])]) ^
 2014              		.loc 1 506 12 is_stmt 0 view .LVU687
 2015 004e CDE900C7 		strd	ip, r7, [sp]
 512:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[2])]) ^
 2016              		.loc 1 512 5 is_stmt 1 view .LVU688
 518:simpleserial-glitch.c ****              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[3])]) ^
 2017              		.loc 1 518 12 is_stmt 0 view .LVU689
 2018 0052 CDE90265 		strd	r6, r5, [sp, #8]
 524:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);
 2019              		.loc 1 524 5 is_stmt 1 view .LVU690
 524:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);
 2020              		.loc 1 524 5 view .LVU691
 2021              	.LVL144:
 2022              	.LBB166:
 2023              	.LBI153:
 194:alignment.h   **** {
 2024              		.loc 2 194 20 view .LVU692
 2025              	.LBB155:
 2026              		.loc 2 203 5 view .LVU693
 2027              		.loc 2 203 5 is_stmt 0 view .LVU694
 2028              	.LBE155:
 2029              	.LBE166:
 524:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);
 2030              		.loc 1 524 46 is_stmt 1 view .LVU695
 525:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);
 2031              		.loc 1 525 5 view .LVU696
 525:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);
 2032              		.loc 1 525 5 view .LVU697
 2033              	.LBB167:
 2034              	.LBI156:
 194:alignment.h   **** {
 2035              		.loc 2 194 20 view .LVU698
 2036              	.LBB158:
 2037              		.loc 2 203 5 view .LVU699
 2038              		.loc 2 203 5 is_stmt 0 view .LVU700
 2039              	.LBE158:
 2040              	.LBE167:
 525:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);
 2041              		.loc 1 525 46 is_stmt 1 view .LVU701
 526:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);
 2042              		.loc 1 526 5 view .LVU702
 526:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);
 2043              		.loc 1 526 5 view .LVU703
 2044              	.LBB168:
 2045              	.LBI159:
 194:alignment.h   **** {
 2046              		.loc 2 194 20 view .LVU704
 2047              	.LBB161:
 2048              		.loc 2 203 5 view .LVU705
 2049              		.loc 2 203 5 is_stmt 0 view .LVU706
 2050              	.LBE161:
 2051              	.LBE168:
 526:simpleserial-glitch.c ****     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);
 2052              		.loc 1 526 46 is_stmt 1 view .LVU707
 527:simpleserial-glitch.c **** 
 2053              		.loc 1 527 5 view .LVU708
 527:simpleserial-glitch.c **** 
 2054              		.loc 1 527 5 view .LVU709
 2055              	.LBB169:
 2056              	.LBI162:
 194:alignment.h   **** {
 2057              		.loc 2 194 20 view .LVU710
 2058              	.LBB164:
 2059              		.loc 2 203 5 view .LVU711
 2060              		.loc 2 203 5 is_stmt 0 view .LVU712
 2061              	.LBE164:
 2062              	.LBE169:
 527:simpleserial-glitch.c **** 
 2063              		.loc 1 527 46 is_stmt 1 view .LVU713
 529:simpleserial-glitch.c **** 
 2064              		.loc 1 529 5 view .LVU714
 2065              	.LBB170:
 2066              	.LBI149:
 281:simpleserial-glitch.c **** {
 2067              		.loc 1 281 6 view .LVU715
 2068              	.LBB152:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 2069              		.loc 1 283 5 view .LVU716
 2070 0056 FFF7FEFF 		bl	mbedtls_platform_zeroize.part.0
 2071              	.LVL145:
 283:simpleserial-glitch.c ****         memset_func(buf, 0, len);
 2072              		.loc 1 283 5 is_stmt 0 view .LVU717
 2073              	.LBE152:
 2074              	.LBE170:
 531:simpleserial-glitch.c **** }
 2075              		.loc 1 531 5 is_stmt 1 view .LVU718
 532:simpleserial-glitch.c **** #endif /* !MBEDTLS_AES_DECRYPT_ALT && !MBEDTLS_BLOCK_CIPHER_NO_DECRYPT */
 2076              		.loc 1 532 1 is_stmt 0 view .LVU719
 2077 005a 0020     		movs	r0, #0
 2078 005c 08B0     		add	sp, sp, #32
 2079              	.LCFI17:
 2080              		.cfi_remember_state
 2081              		.cfi_def_cfa_offset 32
 2082              		@ sp needed
 2083 005e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2084              	.LVL146:
 2085              	.L70:
 2086              	.LCFI18:
 2087              		.cfi_restore_state
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2088              		.loc 1 494 9 is_stmt 1 discriminator 3 view .LVU720
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2089              		.loc 1 494 9 discriminator 3 view .LVU721
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2090              		.loc 1 494 9 discriminator 3 view .LVU722
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2091              		.loc 1 494 9 discriminator 3 view .LVU723
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2092              		.loc 1 494 9 discriminator 3 view .LVU724
 494:simpleserial-glitch.c ****         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);
 2093              		.loc 1 494 9 discriminator 3 view .LVU725
 495:simpleserial-glitch.c ****     }
 2094              		.loc 1 495 9 discriminator 3 view .LVU726
 495:simpleserial-glitch.c ****     }
 2095              		.loc 1 495 9 discriminator 3 view .LVU727
 495:simpleserial-glitch.c ****     }
 2096              		.loc 1 495 9 discriminator 3 view .LVU728
 495:simpleserial-glitch.c ****     }
 2097              		.loc 1 495 9 discriminator 3 view .LVU729
 495:simpleserial-glitch.c ****     }
 2098              		.loc 1 495 9 discriminator 3 view .LVU730
 2099 0062 2033     		adds	r3, r3, #32
 2100              	.LVL147:
 495:simpleserial-glitch.c ****     }
 2101              		.loc 1 495 9 discriminator 3 view .LVU731
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 2102              		.loc 1 493 41 discriminator 3 view .LVU732
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 2103              		.loc 1 493 42 is_stmt 0 discriminator 3 view .LVU733
 2104 0064 0AF1FF3A 		add	r10, r10, #-1
 2105              	.LVL148:
 493:simpleserial-glitch.c ****         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);
 2106              		.loc 1 493 42 discriminator 3 view .LVU734
 2107 0068 D6E7     		b	.L69
 2108              		.cfi_endproc
 2109              	.LFE21:
 2111              		.section	.text.mbedtls_aes_crypt_ecb,"ax",%progbits
 2112              		.align	1
 2113              		.global	mbedtls_aes_crypt_ecb
 2114              		.syntax unified
 2115              		.thumb
 2116              		.thumb_func
 2118              	mbedtls_aes_crypt_ecb:
 2119              	.LVL149:
 2120              	.LFB22:
 542:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 2121              		.loc 1 542 1 is_stmt 1 view -0
 2122              		.cfi_startproc
 2123              		@ args = 0, pretend = 0, frame = 0
 2124              		@ frame_needed = 0, uses_anonymous_args = 0
 2125              		@ link register save eliminated.
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2126              		.loc 1 543 5 view .LVU736
 542:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 2127              		.loc 1 542 1 is_stmt 0 view .LVU737
 2128 0000 10B4     		push	{r4}
 2129              	.LCFI19:
 2130              		.cfi_def_cfa_offset 4
 2131              		.cfi_offset 4, -4
 542:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 2132              		.loc 1 542 1 view .LVU738
 2133 0002 0C46     		mov	r4, r1
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2134              		.loc 1 543 8 view .LVU739
 2135 0004 012C     		cmp	r4, #1
 542:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 2136              		.loc 1 542 1 view .LVU740
 2137 0006 1146     		mov	r1, r2
 2138              	.LVL150:
 542:simpleserial-glitch.c ****     if (mode != MBEDTLS_AES_ENCRYPT && mode != MBEDTLS_AES_DECRYPT) {
 2139              		.loc 1 542 1 view .LVU741
 2140 0008 1A46     		mov	r2, r3
 2141              	.LVL151:
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2142              		.loc 1 543 8 view .LVU742
 2143 000a 06D8     		bhi	.L72
 549:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 2144              		.loc 1 549 5 is_stmt 1 view .LVU743
 549:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 2145              		.loc 1 549 8 is_stmt 0 view .LVU744
 2146 000c 14B9     		cbnz	r4, .L73
 550:simpleserial-glitch.c ****     } else
 2147              		.loc 1 550 9 is_stmt 1 view .LVU745
 557:simpleserial-glitch.c **** 
 2148              		.loc 1 557 1 is_stmt 0 view .LVU746
 2149 000e 10BC     		pop	{r4}
 2150              	.LCFI20:
 2151              		.cfi_remember_state
 2152              		.cfi_restore 4
 2153              		.cfi_def_cfa_offset 0
 2154              	.LVL152:
 550:simpleserial-glitch.c ****     } else
 2155              		.loc 1 550 16 view .LVU747
 2156 0010 FFF7FEBF 		b	mbedtls_internal_aes_decrypt
 2157              	.LVL153:
 2158              	.L73:
 2159              	.LCFI21:
 2160              		.cfi_restore_state
 554:simpleserial-glitch.c ****     }
 2161              		.loc 1 554 9 is_stmt 1 view .LVU748
 557:simpleserial-glitch.c **** 
 2162              		.loc 1 557 1 is_stmt 0 view .LVU749
 2163 0014 10BC     		pop	{r4}
 2164              	.LCFI22:
 2165              		.cfi_remember_state
 2166              		.cfi_restore 4
 2167              		.cfi_def_cfa_offset 0
 2168              	.LVL154:
 554:simpleserial-glitch.c ****     }
 2169              		.loc 1 554 16 view .LVU750
 2170 0016 FFF7FEBF 		b	mbedtls_internal_aes_encrypt
 2171              	.LVL155:
 2172              	.L72:
 2173              	.LCFI23:
 2174              		.cfi_restore_state
 557:simpleserial-glitch.c **** 
 2175              		.loc 1 557 1 view .LVU751
 2176 001a 6FF02000 		mvn	r0, #32
 2177              	.LVL156:
 557:simpleserial-glitch.c **** 
 2178              		.loc 1 557 1 view .LVU752
 2179 001e 10BC     		pop	{r4}
 2180              	.LCFI24:
 2181              		.cfi_restore 4
 2182              		.cfi_def_cfa_offset 0
 2183              	.LVL157:
 557:simpleserial-glitch.c **** 
 2184              		.loc 1 557 1 view .LVU753
 2185 0020 7047     		bx	lr
 2186              		.cfi_endproc
 2187              	.LFE22:
 2189              		.section	.text.mbedtls_aes_crypt_cbc,"ax",%progbits
 2190              		.align	1
 2191              		.global	mbedtls_aes_crypt_cbc
 2192              		.syntax unified
 2193              		.thumb
 2194              		.thumb_func
 2196              	mbedtls_aes_crypt_cbc:
 2197              	.LVL158:
 2198              	.LFB23:
 570:simpleserial-glitch.c ****     int ret;
 2199              		.loc 1 570 1 is_stmt 1 view -0
 2200              		.cfi_startproc
 2201              		@ args = 8, pretend = 0, frame = 16
 2202              		@ frame_needed = 0, uses_anonymous_args = 0
 571:simpleserial-glitch.c ****     unsigned char temp[16];
 2203              		.loc 1 571 5 view .LVU755
 572:simpleserial-glitch.c **** 
 2204              		.loc 1 572 5 view .LVU756
 574:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2205              		.loc 1 574 5 view .LVU757
 570:simpleserial-glitch.c ****     int ret;
 2206              		.loc 1 570 1 is_stmt 0 view .LVU758
 2207 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2208              	.LCFI25:
 2209              		.cfi_def_cfa_offset 36
 2210              		.cfi_offset 4, -36
 2211              		.cfi_offset 5, -32
 2212              		.cfi_offset 6, -28
 2213              		.cfi_offset 7, -24
 2214              		.cfi_offset 8, -20
 2215              		.cfi_offset 9, -16
 2216              		.cfi_offset 10, -12
 2217              		.cfi_offset 11, -8
 2218              		.cfi_offset 14, -4
 574:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2219              		.loc 1 574 8 view .LVU759
 2220 0004 0129     		cmp	r1, #1
 570:simpleserial-glitch.c ****     int ret;
 2221              		.loc 1 570 1 view .LVU760
 2222 0006 85B0     		sub	sp, sp, #20
 2223              	.LCFI26:
 2224              		.cfi_def_cfa_offset 56
 570:simpleserial-glitch.c ****     int ret;
 2225              		.loc 1 570 1 view .LVU761
 2226 0008 DDE90E46 		ldrd	r4, r6, [sp, #56]
 2227 000c 0746     		mov	r7, r0
 2228 000e 1546     		mov	r5, r2
 2229 0010 9846     		mov	r8, r3
 574:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2230              		.loc 1 574 8 view .LVU762
 2231 0012 5CD8     		bhi	.L86
 579:simpleserial-glitch.c ****         return 0;
 2232              		.loc 1 579 5 is_stmt 1 view .LVU763
 579:simpleserial-glitch.c ****         return 0;
 2233              		.loc 1 579 8 is_stmt 0 view .LVU764
 2234 0014 1AB9     		cbnz	r2, .L76
 2235              	.LVL159:
 2236              	.L82:
 580:simpleserial-glitch.c ****     }
 2237              		.loc 1 580 16 view .LVU765
 2238 0016 0020     		movs	r0, #0
 2239              	.L74:
 627:simpleserial-glitch.c **** #endif /* MBEDTLS_CIPHER_MODE_CBC */
 2240              		.loc 1 627 1 view .LVU766
 2241 0018 05B0     		add	sp, sp, #20
 2242              	.LCFI27:
 2243              		.cfi_remember_state
 2244              		.cfi_def_cfa_offset 36
 2245              		@ sp needed
 2246 001a BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2247              	.LVL160:
 2248              	.L76:
 2249              	.LCFI28:
 2250              		.cfi_restore_state
 583:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 2251              		.loc 1 583 5 is_stmt 1 view .LVU767
 583:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 2252              		.loc 1 583 8 is_stmt 0 view .LVU768
 2253 001e 1307     		lsls	r3, r2, #28
 2254              	.LVL161:
 583:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
 2255              		.loc 1 583 8 view .LVU769
 2256 0020 58D1     		bne	.L87
 587:simpleserial-glitch.c **** 
 2257              		.loc 1 587 5 is_stmt 1 view .LVU770
 2258              	.LVL162:
 589:simpleserial-glitch.c ****         while (length > 0) {
 2259              		.loc 1 589 5 view .LVU771
 589:simpleserial-glitch.c ****         while (length > 0) {
 2260              		.loc 1 589 8 is_stmt 0 view .LVU772
 2261 0022 0029     		cmp	r1, #0
 2262 0024 48D1     		bne	.L88
 601:simpleserial-glitch.c **** 
 2263              		.loc 1 601 13 view .LVU773
 2264 0026 0DF1100A 		add	r10, sp, #16
 590:simpleserial-glitch.c ****             memcpy(temp, input, 16);
 2265              		.loc 1 590 15 view .LVU774
 2266 002a 2544     		add	r5, r5, r4
 2267              	.LVL163:
 2268              	.L81:
 591:simpleserial-glitch.c ****             ret = mbedtls_aes_crypt_ecb(ctx, mode, input, output);
 2269              		.loc 1 591 13 is_stmt 1 view .LVU775
 2270 002c 6A46     		mov	r2, sp
 2271 002e 2346     		mov	r3, r4
 2272 0030 04F1100B 		add	fp, r4, #16
 2273 0034 9146     		mov	r9, r2
 2274              	.L78:
 591:simpleserial-glitch.c ****             ret = mbedtls_aes_crypt_ecb(ctx, mode, input, output);
 2275              		.loc 1 591 13 is_stmt 0 view .LVU776
 2276 0036 1868     		ldr	r0, [r3]	@ unaligned
 2277 0038 5968     		ldr	r1, [r3, #4]	@ unaligned
 2278 003a 9446     		mov	ip, r2
 2279 003c ACE80300 		stmia	ip!, {r0, r1}
 2280 0040 0833     		adds	r3, r3, #8
 2281 0042 5B45     		cmp	r3, fp
 2282 0044 6246     		mov	r2, ip
 2283 0046 F6D1     		bne	.L78
 592:simpleserial-glitch.c ****             if (ret != 0) {
 2284              		.loc 1 592 13 is_stmt 1 view .LVU777
 2285              	.LVL164:
 2286              	.LBB185:
 2287              	.LBI185:
 538:simpleserial-glitch.c ****                           int mode,
 2288              		.loc 1 538 5 view .LVU778
 2289              	.LBB186:
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2290              		.loc 1 543 5 view .LVU779
 549:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 2291              		.loc 1 549 5 view .LVU780
 550:simpleserial-glitch.c ****     } else
 2292              		.loc 1 550 9 view .LVU781
 550:simpleserial-glitch.c ****     } else
 2293              		.loc 1 550 16 is_stmt 0 view .LVU782
 2294 0048 3246     		mov	r2, r6
 2295 004a 2146     		mov	r1, r4
 2296 004c 3846     		mov	r0, r7
 2297 004e FFF7FEFF 		bl	mbedtls_internal_aes_decrypt
 2298              	.LVL165:
 550:simpleserial-glitch.c ****     } else
 2299              		.loc 1 550 16 view .LVU783
 2300              	.LBE186:
 2301              	.LBE185:
 593:simpleserial-glitch.c ****                 goto exit;
 2302              		.loc 1 593 13 is_stmt 1 view .LVU784
 593:simpleserial-glitch.c ****                 goto exit;
 2303              		.loc 1 593 16 is_stmt 0 view .LVU785
 2304 0052 0028     		cmp	r0, #0
 2305 0054 E0D1     		bne	.L74
 2306              	.LVL166:
 2307              	.L79:
 2308              	.LBB187:
 2309              	.LBB188:
 2310              	.LBB189:
 2311              		.file 3 "common.h"
   1:common.h      **** /**
   2:common.h      ****  * \file common.h
   3:common.h      ****  *
   4:common.h      ****  * \brief Utility macros for internal use in the library
   5:common.h      ****  */
   6:common.h      **** /*
   7:common.h      ****  *  Copyright The Mbed TLS Contributors
   8:common.h      ****  *  SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later
   9:common.h      ****  */
  10:common.h      **** 
  11:common.h      **** #ifndef MBEDTLS_LIBRARY_COMMON_H
  12:common.h      **** #define MBEDTLS_LIBRARY_COMMON_H
  13:common.h      **** 
  14:common.h      **** #include "build_info.h"
  15:common.h      **** #include "alignment.h"
  16:common.h      **** 
  17:common.h      **** #include <assert.h>
  18:common.h      **** #include <stddef.h>
  19:common.h      **** #include <stdint.h>
  20:common.h      **** #include <stddef.h>
  21:common.h      **** 
  22:common.h      **** #if defined(__ARM_NEON)
  23:common.h      **** #include <arm_neon.h>
  24:common.h      **** #define MBEDTLS_HAVE_NEON_INTRINSICS
  25:common.h      **** #elif defined(MBEDTLS_PLATFORM_IS_WINDOWS_ON_ARM64)
  26:common.h      **** #include <arm64_neon.h>
  27:common.h      **** #define MBEDTLS_HAVE_NEON_INTRINSICS
  28:common.h      **** #endif
  29:common.h      **** 
  30:common.h      **** /** Helper to define a function as static except when building invasive tests.
  31:common.h      ****  *
  32:common.h      ****  * If a function is only used inside its own source file and should be
  33:common.h      ****  * declared `static` to allow the compiler to optimize for code size,
  34:common.h      ****  * but that function has unit tests, define it with
  35:common.h      ****  * ```
  36:common.h      ****  * MBEDTLS_STATIC_TESTABLE int mbedtls_foo(...) { ... }
  37:common.h      ****  * ```
  38:common.h      ****  * and declare it in a header in the `library/` directory with
  39:common.h      ****  * ```
  40:common.h      ****  * #if defined(MBEDTLS_TEST_HOOKS)
  41:common.h      ****  * int mbedtls_foo(...);
  42:common.h      ****  * #endif
  43:common.h      ****  * ```
  44:common.h      ****  */
  45:common.h      **** #if defined(MBEDTLS_TEST_HOOKS)
  46:common.h      **** #define MBEDTLS_STATIC_TESTABLE
  47:common.h      **** #else
  48:common.h      **** #define MBEDTLS_STATIC_TESTABLE static
  49:common.h      **** #endif
  50:common.h      **** 
  51:common.h      **** #if defined(MBEDTLS_TEST_HOOKS)
  52:common.h      **** extern void (*mbedtls_test_hook_test_fail)(const char *test, int line, const char *file);
  53:common.h      **** #define MBEDTLS_TEST_HOOK_TEST_ASSERT(TEST) \
  54:common.h      ****     do { \
  55:common.h      ****         if ((!(TEST)) && ((*mbedtls_test_hook_test_fail) != NULL)) \
  56:common.h      ****         { \
  57:common.h      ****             (*mbedtls_test_hook_test_fail)( #TEST, __LINE__, __FILE__); \
  58:common.h      ****         } \
  59:common.h      ****     } while (0)
  60:common.h      **** #else
  61:common.h      **** #define MBEDTLS_TEST_HOOK_TEST_ASSERT(TEST)
  62:common.h      **** #endif /* defined(MBEDTLS_TEST_HOOKS) */
  63:common.h      **** 
  64:common.h      **** /** \def ARRAY_LENGTH
  65:common.h      ****  * Return the number of elements of a static or stack array.
  66:common.h      ****  *
  67:common.h      ****  * \param array         A value of array (not pointer) type.
  68:common.h      ****  *
  69:common.h      ****  * \return The number of elements of the array.
  70:common.h      ****  */
  71:common.h      **** /* A correct implementation of ARRAY_LENGTH, but which silently gives
  72:common.h      ****  * a nonsensical result if called with a pointer rather than an array. */
  73:common.h      **** #define ARRAY_LENGTH_UNSAFE(array)            \
  74:common.h      ****     (sizeof(array) / sizeof(*(array)))
  75:common.h      **** 
  76:common.h      **** #if defined(__GNUC__)
  77:common.h      **** /* Test if arg and &(arg)[0] have the same type. This is true if arg is
  78:common.h      ****  * an array but not if it's a pointer. */
  79:common.h      **** #define IS_ARRAY_NOT_POINTER(arg)                                     \
  80:common.h      ****     (!__builtin_types_compatible_p(__typeof__(arg),                \
  81:common.h      ****                                    __typeof__(&(arg)[0])))
  82:common.h      **** /* A compile-time constant with the value 0. If `const_expr` is not a
  83:common.h      ****  * compile-time constant with a nonzero value, cause a compile-time error. */
  84:common.h      **** #define STATIC_ASSERT_EXPR(const_expr)                                \
  85:common.h      ****     (0 && sizeof(struct { unsigned int STATIC_ASSERT : 1 - 2 * !(const_expr); }))
  86:common.h      **** 
  87:common.h      **** /* Return the scalar value `value` (possibly promoted). This is a compile-time
  88:common.h      ****  * constant if `value` is. `condition` must be a compile-time constant.
  89:common.h      ****  * If `condition` is false, arrange to cause a compile-time error. */
  90:common.h      **** #define STATIC_ASSERT_THEN_RETURN(condition, value)   \
  91:common.h      ****     (STATIC_ASSERT_EXPR(condition) ? 0 : (value))
  92:common.h      **** 
  93:common.h      **** #define ARRAY_LENGTH(array)                                           \
  94:common.h      ****     (STATIC_ASSERT_THEN_RETURN(IS_ARRAY_NOT_POINTER(array),         \
  95:common.h      ****                                ARRAY_LENGTH_UNSAFE(array)))
  96:common.h      **** 
  97:common.h      **** #else
  98:common.h      **** /* If we aren't sure the compiler supports our non-standard tricks,
  99:common.h      ****  * fall back to the unsafe implementation. */
 100:common.h      **** #define ARRAY_LENGTH(array) ARRAY_LENGTH_UNSAFE(array)
 101:common.h      **** #endif
 102:common.h      **** /** Allow library to access its structs' private members.
 103:common.h      ****  *
 104:common.h      ****  * Although structs defined in header files are publicly available,
 105:common.h      ****  * their members are private and should not be accessed by the user.
 106:common.h      ****  */
 107:common.h      **** #define MBEDTLS_ALLOW_PRIVATE_ACCESS
 108:common.h      **** 
 109:common.h      **** /**
 110:common.h      ****  * \brief       Securely zeroize a buffer then free it.
 111:common.h      ****  *
 112:common.h      ****  *              Similar to making consecutive calls to
 113:common.h      ****  *              \c mbedtls_platform_zeroize() and \c mbedtls_free(), but has
 114:common.h      ****  *              code size savings, and potential for optimisation in the future.
 115:common.h      ****  *
 116:common.h      ****  *              Guaranteed to be a no-op if \p buf is \c NULL and \p len is 0.
 117:common.h      ****  *
 118:common.h      ****  * \param buf   Buffer to be zeroized then freed.
 119:common.h      ****  * \param len   Length of the buffer in bytes
 120:common.h      ****  */
 121:common.h      **** void mbedtls_zeroize_and_free(void *buf, size_t len);
 122:common.h      **** 
 123:common.h      **** /** Return an offset into a buffer.
 124:common.h      ****  *
 125:common.h      ****  * This is just the addition of an offset to a pointer, except that this
 126:common.h      ****  * function also accepts an offset of 0 into a buffer whose pointer is null.
 127:common.h      ****  * (`p + n` has undefined behavior when `p` is null, even when `n == 0`.
 128:common.h      ****  * A null pointer is a valid buffer pointer when the size is 0, for example
 129:common.h      ****  * as the result of `malloc(0)` on some platforms.)
 130:common.h      ****  *
 131:common.h      ****  * \param p     Pointer to a buffer of at least n bytes.
 132:common.h      ****  *              This may be \p NULL if \p n is zero.
 133:common.h      ****  * \param n     An offset in bytes.
 134:common.h      ****  * \return      Pointer to offset \p n in the buffer \p p.
 135:common.h      ****  *              Note that this is only a valid pointer if the size of the
 136:common.h      ****  *              buffer is at least \p n + 1.
 137:common.h      ****  */
 138:common.h      **** static inline unsigned char *mbedtls_buffer_offset(
 139:common.h      ****     unsigned char *p, size_t n)
 140:common.h      **** {
 141:common.h      ****     return p == NULL ? NULL : p + n;
 142:common.h      **** }
 143:common.h      **** 
 144:common.h      **** /** Return an offset into a read-only buffer.
 145:common.h      ****  *
 146:common.h      ****  * Similar to mbedtls_buffer_offset(), but for const pointers.
 147:common.h      ****  *
 148:common.h      ****  * \param p     Pointer to a buffer of at least n bytes.
 149:common.h      ****  *              This may be \p NULL if \p n is zero.
 150:common.h      ****  * \param n     An offset in bytes.
 151:common.h      ****  * \return      Pointer to offset \p n in the buffer \p p.
 152:common.h      ****  *              Note that this is only a valid pointer if the size of the
 153:common.h      ****  *              buffer is at least \p n + 1.
 154:common.h      ****  */
 155:common.h      **** static inline const unsigned char *mbedtls_buffer_offset_const(
 156:common.h      ****     const unsigned char *p, size_t n)
 157:common.h      **** {
 158:common.h      ****     return p == NULL ? NULL : p + n;
 159:common.h      **** }
 160:common.h      **** 
 161:common.h      **** /* Always inline mbedtls_xor() for similar reasons as mbedtls_xor_no_simd(). */
 162:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 163:common.h      **** #pragma inline = forced
 164:common.h      **** #elif defined(__GNUC__)
 165:common.h      **** __attribute__((always_inline))
 166:common.h      **** #endif
 167:common.h      **** /**
 168:common.h      ****  * Perform a fast block XOR operation, such that
 169:common.h      ****  * r[i] = a[i] ^ b[i] where 0 <= i < n
 170:common.h      ****  *
 171:common.h      ****  * \param   r Pointer to result (buffer of at least \p n bytes). \p r
 172:common.h      ****  *            may be equal to either \p a or \p b, but behaviour when
 173:common.h      ****  *            it overlaps in other ways is undefined.
 174:common.h      ****  * \param   a Pointer to input (buffer of at least \p n bytes)
 175:common.h      ****  * \param   b Pointer to input (buffer of at least \p n bytes)
 176:common.h      ****  * \param   n Number of bytes to process.
 177:common.h      ****  *
 178:common.h      ****  * \note      Depending on the situation, it may be faster to use either mbedtls_xor() or
 179:common.h      ****  *            mbedtls_xor_no_simd() (these are functionally equivalent).
 180:common.h      ****  *            If the result is used immediately after the xor operation in non-SIMD code (e.g, in
 181:common.h      ****  *            AES-CBC), there may be additional latency to transfer the data from SIMD to scalar
 182:common.h      ****  *            registers, and in this case, mbedtls_xor_no_simd() may be faster. In other cases wher
 183:common.h      ****  *            the result is not used immediately (e.g., in AES-CTR), mbedtls_xor() may be faster.
 184:common.h      ****  *            For targets without SIMD support, they will behave the same.
 185:common.h      ****  */
 186:common.h      **** static inline void mbedtls_xor(unsigned char *r,
 187:common.h      ****                                const unsigned char *a,
 188:common.h      ****                                const unsigned char *b,
 189:common.h      ****                                size_t n)
 190:common.h      **** {
 191:common.h      ****     size_t i = 0;
 192:common.h      **** #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
 193:common.h      **** #if defined(MBEDTLS_HAVE_NEON_INTRINSICS) && \
 194:common.h      ****     (!(defined(MBEDTLS_COMPILER_IS_GCC) && MBEDTLS_GCC_VERSION < 70300))
 195:common.h      ****     /* Old GCC versions generate a warning here, so disable the NEON path for these compilers */
 196:common.h      ****     for (; (i + 16) <= n; i += 16) {
 197:common.h      ****         uint8x16_t v1 = vld1q_u8(a + i);
 198:common.h      ****         uint8x16_t v2 = vld1q_u8(b + i);
 199:common.h      ****         uint8x16_t x = veorq_u8(v1, v2);
 200:common.h      ****         vst1q_u8(r + i, x);
 201:common.h      ****     }
 202:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 203:common.h      ****     /* This if statement helps some compilers (e.g., IAR) optimise out the byte-by-byte tail case
 204:common.h      ****      * where n is a constant multiple of 16.
 205:common.h      ****      * For other compilers (e.g. recent gcc and clang) it makes no difference if n is a compile-tim
 206:common.h      ****      * constant, and is a very small perf regression if n is not a compile-time constant. */
 207:common.h      ****     if (n % 16 == 0) {
 208:common.h      ****         return;
 209:common.h      ****     }
 210:common.h      **** #endif
 211:common.h      **** #elif defined(MBEDTLS_ARCH_IS_X64) || defined(MBEDTLS_ARCH_IS_ARM64)
 212:common.h      ****     /* This codepath probably only makes sense on architectures with 64-bit registers */
 213:common.h      ****     for (; (i + 8) <= n; i += 8) {
 214:common.h      ****         uint64_t x = mbedtls_get_unaligned_uint64(a + i) ^ mbedtls_get_unaligned_uint64(b + i);
 215:common.h      ****         mbedtls_put_unaligned_uint64(r + i, x);
 216:common.h      ****     }
 217:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 218:common.h      ****     if (n % 8 == 0) {
 219:common.h      ****         return;
 220:common.h      ****     }
 221:common.h      **** #endif
 222:common.h      **** #else
 223:common.h      ****     for (; (i + 4) <= n; i += 4) {
 224:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 225:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 226:common.h      ****     }
 227:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 228:common.h      ****     if (n % 4 == 0) {
 229:common.h      ****         return;
 230:common.h      ****     }
 231:common.h      **** #endif
 232:common.h      **** #endif
 233:common.h      **** #endif
 234:common.h      ****     for (; i < n; i++) {
 235:common.h      ****         r[i] = a[i] ^ b[i];
 236:common.h      ****     }
 237:common.h      **** }
 238:common.h      **** 
 239:common.h      **** /* Always inline mbedtls_xor_no_simd() as we see significant perf regressions when it does not get
 240:common.h      ****  * inlined (e.g., observed about 3x perf difference in gcm_mult_largetable with gcc 7 - 12) */
 241:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 242:common.h      **** #pragma inline = forced
 243:common.h      **** #elif defined(__GNUC__)
 244:common.h      **** __attribute__((always_inline))
 245:common.h      **** #endif
 246:common.h      **** /**
 247:common.h      ****  * Perform a fast block XOR operation, such that
 248:common.h      ****  * r[i] = a[i] ^ b[i] where 0 <= i < n
 249:common.h      ****  *
 250:common.h      ****  * In some situations, this can perform better than mbedtls_xor() (e.g., it's about 5%
 251:common.h      ****  * better in AES-CBC).
 252:common.h      ****  *
 253:common.h      ****  * \param   r Pointer to result (buffer of at least \p n bytes). \p r
 254:common.h      ****  *            may be equal to either \p a or \p b, but behaviour when
 255:common.h      ****  *            it overlaps in other ways is undefined.
 256:common.h      ****  * \param   a Pointer to input (buffer of at least \p n bytes)
 257:common.h      ****  * \param   b Pointer to input (buffer of at least \p n bytes)
 258:common.h      ****  * \param   n Number of bytes to process.
 259:common.h      ****  *
 260:common.h      ****  * \note      Depending on the situation, it may be faster to use either mbedtls_xor() or
 261:common.h      ****  *            mbedtls_xor_no_simd() (these are functionally equivalent).
 262:common.h      ****  *            If the result is used immediately after the xor operation in non-SIMD code (e.g, in
 263:common.h      ****  *            AES-CBC), there may be additional latency to transfer the data from SIMD to scalar
 264:common.h      ****  *            registers, and in this case, mbedtls_xor_no_simd() may be faster. In other cases wher
 265:common.h      ****  *            the result is not used immediately (e.g., in AES-CTR), mbedtls_xor() may be faster.
 266:common.h      ****  *            For targets without SIMD support, they will behave the same.
 267:common.h      ****  */
 268:common.h      **** static inline void mbedtls_xor_no_simd(unsigned char *r,
 269:common.h      ****                                        const unsigned char *a,
 270:common.h      ****                                        const unsigned char *b,
 271:common.h      ****                                        size_t n)
 272:common.h      **** {
 273:common.h      ****     size_t i = 0;
 274:common.h      **** #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
 275:common.h      **** #if defined(MBEDTLS_ARCH_IS_X64) || defined(MBEDTLS_ARCH_IS_ARM64)
 276:common.h      ****     /* This codepath probably only makes sense on architectures with 64-bit registers */
 277:common.h      ****     for (; (i + 8) <= n; i += 8) {
 278:common.h      ****         uint64_t x = mbedtls_get_unaligned_uint64(a + i) ^ mbedtls_get_unaligned_uint64(b + i);
 279:common.h      ****         mbedtls_put_unaligned_uint64(r + i, x);
 280:common.h      ****     }
 281:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 282:common.h      ****     /* This if statement helps some compilers (e.g., IAR) optimise out the byte-by-byte tail case
 283:common.h      ****      * where n is a constant multiple of 8.
 284:common.h      ****      * For other compilers (e.g. recent gcc and clang) it makes no difference if n is a compile-tim
 285:common.h      ****      * constant, and is a very small perf regression if n is not a compile-time constant. */
 286:common.h      ****     if (n % 8 == 0) {
 287:common.h      ****         return;
 288:common.h      ****     }
 289:common.h      **** #endif
 290:common.h      **** #else
 291:common.h      ****     for (; (i + 4) <= n; i += 4) {
 292:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2312              		.loc 3 292 9 is_stmt 1 view .LVU786
 2313              		.loc 3 292 9 is_stmt 0 view .LVU787
 2314              	.LBE189:
 2315              	.LBE188:
 2316              	.LBE187:
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 2317              		.loc 2 169 5 is_stmt 1 view .LVU788
 177:alignment.h   **** #endif
 2318              		.loc 2 177 5 view .LVU789
 179:alignment.h   **** }
 2319              		.loc 2 179 5 view .LVU790
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 2320              		.loc 2 169 5 view .LVU791
 177:alignment.h   **** #endif
 2321              		.loc 2 177 5 view .LVU792
 179:alignment.h   **** }
 2322              		.loc 2 179 5 view .LVU793
 2323              	.LBB196:
 2324              	.LBB195:
 2325              	.LBB194:
 293:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2326              		.loc 3 293 9 view .LVU794
 2327              	.LBB190:
 2328              	.LBI190:
 194:alignment.h   **** {
 2329              		.loc 2 194 20 view .LVU795
 2330              	.LBB191:
 2331              		.loc 2 203 5 view .LVU796
 2332              	.LBE191:
 2333              	.LBE190:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2334              		.loc 3 292 18 is_stmt 0 view .LVU797
 2335 0056 58F80030 		ldr	r3, [r8, r0]	@ unaligned
 2336 005a 3258     		ldr	r2, [r6, r0]	@ unaligned
 2337 005c 5340     		eors	r3, r3, r2
 2338              	.LBB193:
 2339              	.LBB192:
 2340              		.loc 2 203 5 view .LVU798
 2341 005e 3350     		str	r3, [r6, r0]	@ unaligned
 2342              	.LVL167:
 2343              		.loc 2 203 5 view .LVU799
 2344              	.LBE192:
 2345              	.LBE193:
 2346              	.LBE194:
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2347              		.loc 3 291 26 is_stmt 1 view .LVU800
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2348              		.loc 3 291 26 is_stmt 0 view .LVU801
 2349 0060 0430     		adds	r0, r0, #4
 2350              	.LVL168:
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2351              		.loc 3 291 12 is_stmt 1 view .LVU802
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2352              		.loc 3 291 5 is_stmt 0 view .LVU803
 2353 0062 1028     		cmp	r0, #16
 2354 0064 F7D1     		bne	.L79
 2355              	.LVL169:
 294:common.h      ****     }
 295:common.h      **** #if defined(__IAR_SYSTEMS_ICC__)
 296:common.h      ****     if (n % 4 == 0) {
 297:common.h      ****         return;
 298:common.h      ****     }
 299:common.h      **** #endif
 300:common.h      **** #endif
 301:common.h      **** #endif
 302:common.h      ****     for (; i < n; i++) {
 2356              		.loc 3 302 12 is_stmt 1 view .LVU804
 2357              		.loc 3 302 12 is_stmt 0 view .LVU805
 2358              	.LBE195:
 2359              	.LBE196:
 601:simpleserial-glitch.c **** 
 2360              		.loc 1 601 13 is_stmt 1 view .LVU806
 2361 0066 4246     		mov	r2, r8
 2362              	.L80:
 2363 0068 4B46     		mov	r3, r9
 2364 006a 03CB     		ldmia	r3!, {r0, r1}
 2365 006c 5345     		cmp	r3, r10
 2366 006e 1060     		str	r0, [r2]	@ unaligned
 2367 0070 5160     		str	r1, [r2, #4]	@ unaligned
 2368 0072 9946     		mov	r9, r3
 2369 0074 02F10802 		add	r2, r2, #8
 2370 0078 F6D1     		bne	.L80
 603:simpleserial-glitch.c ****             output += 16;
 2371              		.loc 1 603 13 view .LVU807
 590:simpleserial-glitch.c ****             memcpy(temp, input, 16);
 2372              		.loc 1 590 15 is_stmt 0 view .LVU808
 2373 007a AB45     		cmp	fp, r5
 603:simpleserial-glitch.c ****             output += 16;
 2374              		.loc 1 603 20 view .LVU809
 2375 007c 5C46     		mov	r4, fp
 2376              	.LVL170:
 604:simpleserial-glitch.c ****             length -= 16;
 2377              		.loc 1 604 13 is_stmt 1 view .LVU810
 604:simpleserial-glitch.c ****             length -= 16;
 2378              		.loc 1 604 20 is_stmt 0 view .LVU811
 2379 007e 06F11006 		add	r6, r6, #16
 2380              	.LVL171:
 605:simpleserial-glitch.c ****         }
 2381              		.loc 1 605 13 is_stmt 1 view .LVU812
 590:simpleserial-glitch.c ****             memcpy(temp, input, 16);
 2382              		.loc 1 590 15 view .LVU813
 2383 0082 D3D1     		bne	.L81
 590:simpleserial-glitch.c ****             memcpy(temp, input, 16);
 2384              		.loc 1 590 15 is_stmt 0 view .LVU814
 2385 0084 C7E7     		b	.L82
 2386              	.LVL172:
 2387              	.L83:
 2388              	.LBB197:
 2389              	.LBB198:
 2390              	.LBB199:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2391              		.loc 3 292 9 is_stmt 1 view .LVU815
 2392              	.LBE199:
 2393              	.LBE198:
 2394              	.LBE197:
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 2395              		.loc 2 169 5 view .LVU816
 177:alignment.h   **** #endif
 2396              		.loc 2 177 5 view .LVU817
 179:alignment.h   **** }
 2397              		.loc 2 179 5 view .LVU818
 169:alignment.h   **** #if defined(UINT_UNALIGNED)
 2398              		.loc 2 169 5 view .LVU819
 177:alignment.h   **** #endif
 2399              		.loc 2 177 5 view .LVU820
 179:alignment.h   **** }
 2400              		.loc 2 179 5 view .LVU821
 2401              	.LBB211:
 2402              	.LBB207:
 2403              	.LBB204:
 293:common.h      ****     }
 2404              		.loc 3 293 9 view .LVU822
 2405              	.LBB200:
 2406              	.LBI200:
 194:alignment.h   **** {
 2407              		.loc 2 194 20 view .LVU823
 2408              	.LBB201:
 2409              		.loc 2 203 5 view .LVU824
 2410              	.LBE201:
 2411              	.LBE200:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2412              		.loc 3 292 18 is_stmt 0 view .LVU825
 2413 0086 4358     		ldr	r3, [r0, r1]	@ unaligned
 2414 0088 52F801C0 		ldr	ip, [r2, r1]	@ unaligned
 2415 008c 83EA0C03 		eor	r3, r3, ip
 2416              	.LBB203:
 2417              	.LBB202:
 2418              		.loc 2 203 5 view .LVU826
 2419 0090 7350     		str	r3, [r6, r1]	@ unaligned
 2420              	.LVL173:
 2421              		.loc 2 203 5 view .LVU827
 2422              	.LBE202:
 2423              	.LBE203:
 2424              	.LBE204:
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2425              		.loc 3 291 26 is_stmt 1 view .LVU828
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2426              		.loc 3 291 26 is_stmt 0 view .LVU829
 2427 0092 0431     		adds	r1, r1, #4
 2428              	.LVL174:
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2429              		.loc 3 291 12 is_stmt 1 view .LVU830
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2430              		.loc 3 291 5 is_stmt 0 view .LVU831
 2431 0094 1029     		cmp	r1, #16
 2432 0096 F6D1     		bne	.L83
 2433              	.LVL175:
 2434              		.loc 3 302 12 is_stmt 1 view .LVU832
 2435              		.loc 3 302 12 is_stmt 0 view .LVU833
 2436              	.LBE207:
 2437              	.LBE211:
 611:simpleserial-glitch.c ****             if (ret != 0) {
 2438              		.loc 1 611 13 is_stmt 1 view .LVU834
 2439              	.LBB212:
 2440              	.LBI212:
 538:simpleserial-glitch.c ****                           int mode,
 2441              		.loc 1 538 5 view .LVU835
 2442              	.LBB213:
 543:simpleserial-glitch.c ****         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
 2443              		.loc 1 543 5 view .LVU836
 549:simpleserial-glitch.c ****         return mbedtls_internal_aes_decrypt(ctx, input, output);
 2444              		.loc 1 549 5 view .LVU837
 554:simpleserial-glitch.c ****     }
 2445              		.loc 1 554 9 view .LVU838
 554:simpleserial-glitch.c ****     }
 2446              		.loc 1 554 16 is_stmt 0 view .LVU839
 2447 0098 3246     		mov	r2, r6
 2448              	.LVL176:
 554:simpleserial-glitch.c ****     }
 2449              		.loc 1 554 16 view .LVU840
 2450 009a 3146     		mov	r1, r6
 2451 009c 3846     		mov	r0, r7
 2452 009e FFF7FEFF 		bl	mbedtls_internal_aes_encrypt
 2453              	.LVL177:
 554:simpleserial-glitch.c ****     }
 2454              		.loc 1 554 16 view .LVU841
 2455              	.LBE213:
 2456              	.LBE212:
 612:simpleserial-glitch.c ****                 goto exit;
 2457              		.loc 1 612 13 is_stmt 1 view .LVU842
 612:simpleserial-glitch.c ****                 goto exit;
 2458              		.loc 1 612 16 is_stmt 0 view .LVU843
 2459 00a2 0028     		cmp	r0, #0
 2460 00a4 B8D1     		bne	.L74
 615:simpleserial-glitch.c **** 
 2461              		.loc 1 615 13 is_stmt 1 view .LVU844
 2462              	.LVL178:
 617:simpleserial-glitch.c ****             output += 16;
 2463              		.loc 1 617 13 view .LVU845
 618:simpleserial-glitch.c ****             length -= 16;
 2464              		.loc 1 618 13 view .LVU846
 608:simpleserial-glitch.c ****             mbedtls_xor_no_simd(output, input, ivp, 16);
 2465              		.loc 1 608 15 is_stmt 0 view .LVU847
 2466 00a6 103D     		subs	r5, r5, #16
 2467              	.LVL179:
 618:simpleserial-glitch.c ****             length -= 16;
 2468              		.loc 1 618 20 view .LVU848
 2469 00a8 06F11001 		add	r1, r6, #16
 2470              	.LVL180:
 619:simpleserial-glitch.c ****         }
 2471              		.loc 1 619 13 is_stmt 1 view .LVU849
 608:simpleserial-glitch.c ****             mbedtls_xor_no_simd(output, input, ivp, 16);
 2472              		.loc 1 608 15 view .LVU850
 2473 00ac 3246     		mov	r2, r6
 2474 00ae 06D0     		beq	.L84
 618:simpleserial-glitch.c ****             length -= 16;
 2475              		.loc 1 618 20 is_stmt 0 view .LVU851
 2476 00b0 0E46     		mov	r6, r1
 2477              	.LVL181:
 2478              	.L77:
 2479              	.LBB214:
 2480              	.LBB208:
 291:common.h      ****         uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
 2481              		.loc 3 291 12 is_stmt 1 view .LVU852
 2482              	.LBE208:
 2483              	.LBE214:
 2484 00b2 0021     		movs	r1, #0
 2485              	.LBB215:
 2486              	.LBB209:
 2487              	.LBB205:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2488              		.loc 3 292 18 is_stmt 0 view .LVU853
 2489 00b4 601B     		subs	r0, r4, r5
 2490 00b6 E6E7     		b	.L83
 2491              	.LVL182:
 2492              	.L88:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2493              		.loc 3 292 18 view .LVU854
 2494              	.LBE205:
 2495              	.LBE209:
 2496              	.LBE215:
 587:simpleserial-glitch.c **** 
 2497              		.loc 1 587 26 view .LVU855
 2498 00b8 4246     		mov	r2, r8
 2499              	.LVL183:
 2500              	.LBB216:
 2501              	.LBB210:
 2502              	.LBB206:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2503              		.loc 3 292 18 view .LVU856
 2504 00ba 2C44     		add	r4, r4, r5
 2505 00bc F9E7     		b	.L77
 2506              	.LVL184:
 2507              	.L84:
 292:common.h      ****         mbedtls_put_unaligned_uint32(r + i, x);
 2508              		.loc 3 292 18 view .LVU857
 2509              	.LBE206:
 2510              	.LBE210:
 2511              	.LBE216:
 621:simpleserial-glitch.c ****     }
 2512              		.loc 1 621 9 is_stmt 1 view .LVU858
 2513 00be 4346     		mov	r3, r8
 2514              	.LVL185:
 2515              	.L85:
 621:simpleserial-glitch.c ****     }
 2516              		.loc 1 621 9 is_stmt 0 view .LVU859
 2517 00c0 52F8044B 		ldr	r4, [r2], #4	@ unaligned
 2518 00c4 43F8044B 		str	r4, [r3], #4	@ unaligned
 2519 00c8 8A42     		cmp	r2, r1
 2520 00ca F9D1     		bne	.L85
 2521 00cc A4E7     		b	.L74
 2522              	.LVL186:
 2523              	.L86:
 575:simpleserial-glitch.c ****     }
 2524              		.loc 1 575 16 view .LVU860
 2525 00ce 6FF02000 		mvn	r0, #32
 2526              	.LVL187:
 575:simpleserial-glitch.c ****     }
 2527              		.loc 1 575 16 view .LVU861
 2528 00d2 A1E7     		b	.L74
 2529              	.LVL188:
 2530              	.L87:
 584:simpleserial-glitch.c ****     }
 2531              		.loc 1 584 16 view .LVU862
 2532 00d4 6FF02100 		mvn	r0, #33
 2533              	.LVL189:
 584:simpleserial-glitch.c ****     }
 2534              		.loc 1 584 16 view .LVU863
 2535 00d8 9EE7     		b	.L74
 2536              		.cfi_endproc
 2537              	.LFE23:
 2539              		.section	.text.startup.main,"ax",%progbits
 2540              		.align	1
 2541              		.global	main
 2542              		.syntax unified
 2543              		.thumb
 2544              		.thumb_func
 2546              	main:
 2547              	.LFB25:
 662:simpleserial-glitch.c **** 
 663:simpleserial-glitch.c **** int main(void)
 664:simpleserial-glitch.c **** {
 2548              		.loc 1 664 1 is_stmt 1 view -0
 2549              		.cfi_startproc
 2550              		@ Volatile: function does not return.
 2551              		@ args = 0, pretend = 0, frame = 0
 2552              		@ frame_needed = 0, uses_anonymous_args = 0
 665:simpleserial-glitch.c ****     platform_init();
 2553              		.loc 1 665 5 view .LVU865
 664:simpleserial-glitch.c ****     platform_init();
 2554              		.loc 1 664 1 is_stmt 0 view .LVU866
 2555 0000 08B5     		push	{r3, lr}
 2556              	.LCFI29:
 2557              		.cfi_def_cfa_offset 8
 2558              		.cfi_offset 3, -8
 2559              		.cfi_offset 14, -4
 2560              		.loc 1 665 5 view .LVU867
 2561 0002 FFF7FEFF 		bl	platform_init
 2562              	.LVL190:
 666:simpleserial-glitch.c ****     init_uart();
 2563              		.loc 1 666 5 is_stmt 1 view .LVU868
 2564 0006 FFF7FEFF 		bl	init_uart
 2565              	.LVL191:
 667:simpleserial-glitch.c ****     trigger_setup();
 2566              		.loc 1 667 5 view .LVU869
 2567 000a FFF7FEFF 		bl	trigger_setup
 2568              	.LVL192:
 668:simpleserial-glitch.c **** 
 669:simpleserial-glitch.c ****     /* Device reset detected */
 670:simpleserial-glitch.c ****     putch('r');
 2569              		.loc 1 670 5 view .LVU870
 2570 000e 7220     		movs	r0, #114
 2571 0010 FFF7FEFF 		bl	putch
 2572              	.LVL193:
 671:simpleserial-glitch.c ****     putch('R');
 2573              		.loc 1 671 5 view .LVU871
 2574 0014 5220     		movs	r0, #82
 2575 0016 FFF7FEFF 		bl	putch
 2576              	.LVL194:
 672:simpleserial-glitch.c ****     putch('E');
 2577              		.loc 1 672 5 view .LVU872
 2578 001a 4520     		movs	r0, #69
 2579 001c FFF7FEFF 		bl	putch
 2580              	.LVL195:
 673:simpleserial-glitch.c ****     putch('S');
 2581              		.loc 1 673 5 view .LVU873
 2582 0020 5320     		movs	r0, #83
 2583 0022 FFF7FEFF 		bl	putch
 2584              	.LVL196:
 674:simpleserial-glitch.c ****     putch('E');
 2585              		.loc 1 674 5 view .LVU874
 2586 0026 4520     		movs	r0, #69
 2587 0028 FFF7FEFF 		bl	putch
 2588              	.LVL197:
 675:simpleserial-glitch.c ****     putch('T');
 2589              		.loc 1 675 5 view .LVU875
 2590 002c 5420     		movs	r0, #84
 2591 002e FFF7FEFF 		bl	putch
 2592              	.LVL198:
 676:simpleserial-glitch.c ****     putch(' ');
 2593              		.loc 1 676 5 view .LVU876
 2594 0032 2020     		movs	r0, #32
 2595 0034 FFF7FEFF 		bl	putch
 2596              	.LVL199:
 677:simpleserial-glitch.c ****     putch(' ');
 2597              		.loc 1 677 5 view .LVU877
 2598 0038 2020     		movs	r0, #32
 2599 003a FFF7FEFF 		bl	putch
 2600              	.LVL200:
 678:simpleserial-glitch.c ****     putch(' ');
 2601              		.loc 1 678 5 view .LVU878
 2602 003e 2020     		movs	r0, #32
 2603 0040 FFF7FEFF 		bl	putch
 2604              	.LVL201:
 679:simpleserial-glitch.c ****     putch('\n');
 2605              		.loc 1 679 5 view .LVU879
 2606 0044 0A20     		movs	r0, #10
 2607 0046 FFF7FEFF 		bl	putch
 2608              	.LVL202:
 680:simpleserial-glitch.c **** 
 681:simpleserial-glitch.c ****     simpleserial_init();
 2609              		.loc 1 681 5 view .LVU880
 2610 004a FFF7FEFF 		bl	simpleserial_init
 2611              	.LVL203:
 682:simpleserial-glitch.c ****     simpleserial_addcmd('a', 16, fault_and_encrypt);  
 2612              		.loc 1 682 5 view .LVU881
 2613 004e 044A     		ldr	r2, .L97
 2614 0050 1021     		movs	r1, #16
 2615 0052 6120     		movs	r0, #97
 2616 0054 FFF7FEFF 		bl	simpleserial_addcmd
 2617              	.LVL204:
 2618              	.L96:
 683:simpleserial-glitch.c **** 
 684:simpleserial-glitch.c ****     while(1)
 2619              		.loc 1 684 5 discriminator 1 view .LVU882
 685:simpleserial-glitch.c ****         simpleserial_get();
 2620              		.loc 1 685 9 discriminator 1 view .LVU883
 2621 0058 FFF7FEFF 		bl	simpleserial_get
 2622              	.LVL205:
 684:simpleserial-glitch.c ****         simpleserial_get();
 2623              		.loc 1 684 10 discriminator 1 view .LVU884
 2624 005c FCE7     		b	.L96
 2625              	.L98:
 2626 005e 00BF     		.align	2
 2627              	.L97:
 2628 0060 00000000 		.word	fault_and_encrypt
 2629              		.cfi_endproc
 2630              	.LFE25:
 2632              		.global	ctx
 2633              		.global	key
 2634              		.global	n_gencalls
 2635              		.data
 2636              		.align	2
 2637              		.set	.LANCHOR1,. + 0
 2640              	memset_func:
 2641 0000 00000000 		.word	memset
 2644              	key:
 2645 0004 5B12A47F 		.ascii	"[\022\244\177+Uq\031\036\300m|\002\374`v"
 2645      2B557119 
 2645      1EC06D7C 
 2645      02FC6076 
 2646              		.bss
 2647              		.align	2
 2648              		.set	.LANCHOR0,. + 0
 2649              		.set	.LANCHOR2,. + 4344
 2652              	round_constants:
 2653 0000 00000000 		.space	40
 2653      00000000 
 2653      00000000 
 2653      00000000 
 2653      00000000 
 2656              	FSb:
 2657 0028 00000000 		.space	256
 2657      00000000 
 2657      00000000 
 2657      00000000 
 2657      00000000 
 2660              	FT0:
 2661 0128 00000000 		.space	1024
 2661      00000000 
 2661      00000000 
 2661      00000000 
 2661      00000000 
 2664              	FT1:
 2665 0528 00000000 		.space	1024
 2665      00000000 
 2665      00000000 
 2665      00000000 
 2665      00000000 
 2668              	FT2:
 2669 0928 00000000 		.space	1024
 2669      00000000 
 2669      00000000 
 2669      00000000 
 2669      00000000 
 2672              	FT3:
 2673 0d28 00000000 		.space	1024
 2673      00000000 
 2673      00000000 
 2673      00000000 
 2673      00000000 
 2676              	aes_init_done:
 2677 1128 00000000 		.space	4
 2680              	n_gencalls:
 2681 112c 00       		.space	1
 2682 112d 000000   		.space	3
 2685              	aes_ctx_done:
 2686 1130 00000000 		.space	4
 2689              	ctx:
 2690 1134 00000000 		.space	280
 2690      00000000 
 2690      00000000 
 2690      00000000 
 2690      00000000 
 2691              		.text
 2692              	.Letext0:
 2693              		.file 4 "/usr/local/Homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/arm-none-eabi/include/machi
 2694              		.file 5 "/usr/local/Homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/arm-none-eabi/include/sys/_
 2695              		.file 6 "/usr/local/Homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.10/gcc/lib/gcc/arm-none-eabi/10.3.
 2696              		.file 7 "aes.h"
 2697              		.file 8 ".././hal/hal.h"
 2698              		.file 9 ".././hal/stm32f3/stm32f3_hal.h"
 2699              		.file 10 ".././simpleserial/simpleserial.h"
 2700              		.file 11 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 simpleserial-glitch.c
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:18     .text.aes_gen_tables:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:23     .text.aes_gen_tables:0000000000000000 aes_gen_tables
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:293    .text.aes_gen_tables:000000000000011c $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:299    .text.mbedtls_platform_zeroize.part.0:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:304    .text.mbedtls_platform_zeroize.part.0:0000000000000000 mbedtls_platform_zeroize.part.0
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:339    .text.mbedtls_platform_zeroize.part.0:0000000000000010 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:344    .text.mbedtls_aes_rk_offset:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:350    .text.mbedtls_aes_rk_offset:0000000000000000 mbedtls_aes_rk_offset
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:369    .text.mbedtls_aes_setkey_enc:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:375    .text.mbedtls_aes_setkey_enc:0000000000000000 mbedtls_aes_setkey_enc
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:830    .text.mbedtls_aes_setkey_enc:00000000000001f4 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:836    .text.mbedtls_aes_init:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:842    .text.mbedtls_aes_init:0000000000000000 mbedtls_aes_init
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:860    .text.mbedtls_aes_free:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:866    .text.mbedtls_aes_free:0000000000000000 mbedtls_aes_free
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:897    .text.mbedtls_platform_zeroize:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:903    .text.mbedtls_platform_zeroize:0000000000000000 mbedtls_platform_zeroize
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:923    .text.mbedtls_aes_setkey_dec:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:929    .text.mbedtls_aes_setkey_dec:0000000000000000 mbedtls_aes_setkey_dec
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1104   .text.mbedtls_internal_aes_encrypt:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1110   .text.mbedtls_internal_aes_encrypt:0000000000000000 mbedtls_internal_aes_encrypt
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1556   .text.mbedtls_internal_aes_encrypt:0000000000000270 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1564   .text.mbedtls_internal_aes_encrypt:0000000000000274 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1740   .text.fault_and_encrypt:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1746   .text.fault_and_encrypt:0000000000000000 fault_and_encrypt
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1868   .text.fault_and_encrypt:0000000000000064 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1876   .text.mbedtls_internal_aes_decrypt:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:1882   .text.mbedtls_internal_aes_decrypt:0000000000000000 mbedtls_internal_aes_decrypt
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2112   .text.mbedtls_aes_crypt_ecb:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2118   .text.mbedtls_aes_crypt_ecb:0000000000000000 mbedtls_aes_crypt_ecb
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2190   .text.mbedtls_aes_crypt_cbc:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2196   .text.mbedtls_aes_crypt_cbc:0000000000000000 mbedtls_aes_crypt_cbc
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2540   .text.startup.main:0000000000000000 $t
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2546   .text.startup.main:0000000000000000 main
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2628   .text.startup.main:0000000000000060 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2689   .bss:0000000000001134 ctx
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2644   .data:0000000000000004 key
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2680   .bss:000000000000112c n_gencalls
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2636   .data:0000000000000000 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2640   .data:0000000000000000 memset_func
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2647   .bss:0000000000000000 $d
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2652   .bss:0000000000000000 round_constants
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2656   .bss:0000000000000028 FSb
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2660   .bss:0000000000000128 FT0
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2664   .bss:0000000000000528 FT1
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2668   .bss:0000000000000928 FT2
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2672   .bss:0000000000000d28 FT3
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2676   .bss:0000000000001128 aes_init_done
/var/folders/x3/jv4w3tks5pv1brl_v53tn7680000gq/T//ccKzVBhs.s:2685   .bss:0000000000001130 aes_ctx_done

UNDEFINED SYMBOLS
trigger_high
trigger_low
memset
puts
simpleserial_put
platform_init
init_uart
trigger_setup
putch
simpleserial_init
simpleserial_addcmd
simpleserial_get
